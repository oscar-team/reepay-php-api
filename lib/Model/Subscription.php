<?php
/**
 * Subscription
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Reepay Checkout API
 *
 * Reepay Checkout REST API
 *
 * OpenAPI spec version: 1
 * Contact: open.source@driveoscar.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * Subscription Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Subscription implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Subscription';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'handle' => 'string',
        'customer' => 'string',
        'plan' => 'string',
        'state' => 'string',
        'test' => 'bool',
        'amount' => 'int',
        'quantity' => 'int',
        'expires' => '\DateTime',
        'reactivated' => '\DateTime',
        'timezone' => 'string',
        'created' => '\DateTime',
        'activated' => '\DateTime',
        'renewing' => 'bool',
        'coupons' => 'string[]',
        'currency' => 'string',
        'plan_version' => 'int',
        'amount_incl_vat' => 'bool',
        'start_date' => '\DateTime',
        'end_date' => '\DateTime',
        'grace_duration' => 'int',
        'current_period_start' => '\DateTime',
        'next_period_start' => '\DateTime',
        'first_period_start' => '\DateTime',
        'last_period_start' => '\DateTime',
        'trial_start' => '\DateTime',
        'trial_end' => '\DateTime',
        'is_cancelled' => 'bool',
        'in_trial' => 'bool',
        'has_started' => 'bool',
        'renewal_count' => 'int',
        'cancelled_date' => '\DateTime',
        'expired_date' => '\DateTime',
        'expire_reason' => 'string',
        'on_hold_date' => '\DateTime',
        'on_hold_reason' => 'string',
        'payment_method_added' => 'bool',
        'scheduled_plan_change' => 'string',
        'reminder_email_sent' => '\DateTime',
        'failed_invoices' => 'int',
        'failed_amount' => 'int',
        'cancelled_invoices' => 'int',
        'cancelled_amount' => 'int',
        'pending_invoices' => 'int',
        'pending_amount' => 'int',
        'dunning_invoices' => 'int',
        'dunning_amount' => 'int',
        'settled_invoices' => 'int',
        'settled_amount' => 'int',
        'refunded_amount' => 'int',
        'pending_additional_costs' => 'int',
        'pending_additional_cost_amount' => 'int',
        'transferred_additional_costs' => 'int',
        'transferred_additional_cost_amount' => 'int',
        'pending_credits' => 'int',
        'pending_credit_amount' => 'int',
        'transferred_credits' => 'int',
        'transferred_credit_amount' => 'int',
        'hosted_page_links' => '\Reepay\Model\SubscriptionLinks',
        'subscription_discounts' => 'string[]',
        'pending_change' => '\Reepay\Model\SubscriptionChange',
        'subscription_changes' => '\Reepay\Model\SubscriptionChange[]',
        'subscription_add_ons' => 'string[]',
        'active_payment_methods' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'handle' => null,
        'customer' => null,
        'plan' => null,
        'state' => null,
        'test' => null,
        'amount' => 'int32',
        'quantity' => 'int32',
        'expires' => 'date-time',
        'reactivated' => 'date-time',
        'timezone' => null,
        'created' => 'date-time',
        'activated' => 'date-time',
        'renewing' => null,
        'coupons' => null,
        'currency' => null,
        'plan_version' => 'int32',
        'amount_incl_vat' => null,
        'start_date' => 'date-time',
        'end_date' => 'date-time',
        'grace_duration' => 'int64',
        'current_period_start' => 'date-time',
        'next_period_start' => 'date-time',
        'first_period_start' => 'date-time',
        'last_period_start' => 'date-time',
        'trial_start' => 'date-time',
        'trial_end' => 'date-time',
        'is_cancelled' => null,
        'in_trial' => null,
        'has_started' => null,
        'renewal_count' => 'int32',
        'cancelled_date' => 'date-time',
        'expired_date' => 'date-time',
        'expire_reason' => null,
        'on_hold_date' => 'date-time',
        'on_hold_reason' => null,
        'payment_method_added' => null,
        'scheduled_plan_change' => null,
        'reminder_email_sent' => 'date-time',
        'failed_invoices' => 'int32',
        'failed_amount' => 'int64',
        'cancelled_invoices' => 'int32',
        'cancelled_amount' => 'int64',
        'pending_invoices' => 'int32',
        'pending_amount' => 'int64',
        'dunning_invoices' => 'int32',
        'dunning_amount' => 'int64',
        'settled_invoices' => 'int32',
        'settled_amount' => 'int64',
        'refunded_amount' => 'int64',
        'pending_additional_costs' => 'int32',
        'pending_additional_cost_amount' => 'int64',
        'transferred_additional_costs' => 'int32',
        'transferred_additional_cost_amount' => 'int64',
        'pending_credits' => 'int32',
        'pending_credit_amount' => 'int64',
        'transferred_credits' => 'int32',
        'transferred_credit_amount' => 'int64',
        'hosted_page_links' => null,
        'subscription_discounts' => null,
        'pending_change' => null,
        'subscription_changes' => null,
        'subscription_add_ons' => null,
        'active_payment_methods' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'handle' => 'handle',
        'customer' => 'customer',
        'plan' => 'plan',
        'state' => 'state',
        'test' => 'test',
        'amount' => 'amount',
        'quantity' => 'quantity',
        'expires' => 'expires',
        'reactivated' => 'reactivated',
        'timezone' => 'timezone',
        'created' => 'created',
        'activated' => 'activated',
        'renewing' => 'renewing',
        'coupons' => 'coupons',
        'currency' => 'currency',
        'plan_version' => 'plan_version',
        'amount_incl_vat' => 'amount_incl_vat',
        'start_date' => 'start_date',
        'end_date' => 'end_date',
        'grace_duration' => 'grace_duration',
        'current_period_start' => 'current_period_start',
        'next_period_start' => 'next_period_start',
        'first_period_start' => 'first_period_start',
        'last_period_start' => 'last_period_start',
        'trial_start' => 'trial_start',
        'trial_end' => 'trial_end',
        'is_cancelled' => 'is_cancelled',
        'in_trial' => 'in_trial',
        'has_started' => 'has_started',
        'renewal_count' => 'renewal_count',
        'cancelled_date' => 'cancelled_date',
        'expired_date' => 'expired_date',
        'expire_reason' => 'expire_reason',
        'on_hold_date' => 'on_hold_date',
        'on_hold_reason' => 'on_hold_reason',
        'payment_method_added' => 'payment_method_added',
        'scheduled_plan_change' => 'scheduled_plan_change',
        'reminder_email_sent' => 'reminder_email_sent',
        'failed_invoices' => 'failed_invoices',
        'failed_amount' => 'failed_amount',
        'cancelled_invoices' => 'cancelled_invoices',
        'cancelled_amount' => 'cancelled_amount',
        'pending_invoices' => 'pending_invoices',
        'pending_amount' => 'pending_amount',
        'dunning_invoices' => 'dunning_invoices',
        'dunning_amount' => 'dunning_amount',
        'settled_invoices' => 'settled_invoices',
        'settled_amount' => 'settled_amount',
        'refunded_amount' => 'refunded_amount',
        'pending_additional_costs' => 'pending_additional_costs',
        'pending_additional_cost_amount' => 'pending_additional_cost_amount',
        'transferred_additional_costs' => 'transferred_additional_costs',
        'transferred_additional_cost_amount' => 'transferred_additional_cost_amount',
        'pending_credits' => 'pending_credits',
        'pending_credit_amount' => 'pending_credit_amount',
        'transferred_credits' => 'transferred_credits',
        'transferred_credit_amount' => 'transferred_credit_amount',
        'hosted_page_links' => 'hosted_page_links',
        'subscription_discounts' => 'subscription_discounts',
        'pending_change' => 'pending_change',
        'subscription_changes' => 'subscription_changes',
        'subscription_add_ons' => 'subscription_add_ons',
        'active_payment_methods' => 'active_payment_methods'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'handle' => 'setHandle',
        'customer' => 'setCustomer',
        'plan' => 'setPlan',
        'state' => 'setState',
        'test' => 'setTest',
        'amount' => 'setAmount',
        'quantity' => 'setQuantity',
        'expires' => 'setExpires',
        'reactivated' => 'setReactivated',
        'timezone' => 'setTimezone',
        'created' => 'setCreated',
        'activated' => 'setActivated',
        'renewing' => 'setRenewing',
        'coupons' => 'setCoupons',
        'currency' => 'setCurrency',
        'plan_version' => 'setPlanVersion',
        'amount_incl_vat' => 'setAmountInclVat',
        'start_date' => 'setStartDate',
        'end_date' => 'setEndDate',
        'grace_duration' => 'setGraceDuration',
        'current_period_start' => 'setCurrentPeriodStart',
        'next_period_start' => 'setNextPeriodStart',
        'first_period_start' => 'setFirstPeriodStart',
        'last_period_start' => 'setLastPeriodStart',
        'trial_start' => 'setTrialStart',
        'trial_end' => 'setTrialEnd',
        'is_cancelled' => 'setIsCancelled',
        'in_trial' => 'setInTrial',
        'has_started' => 'setHasStarted',
        'renewal_count' => 'setRenewalCount',
        'cancelled_date' => 'setCancelledDate',
        'expired_date' => 'setExpiredDate',
        'expire_reason' => 'setExpireReason',
        'on_hold_date' => 'setOnHoldDate',
        'on_hold_reason' => 'setOnHoldReason',
        'payment_method_added' => 'setPaymentMethodAdded',
        'scheduled_plan_change' => 'setScheduledPlanChange',
        'reminder_email_sent' => 'setReminderEmailSent',
        'failed_invoices' => 'setFailedInvoices',
        'failed_amount' => 'setFailedAmount',
        'cancelled_invoices' => 'setCancelledInvoices',
        'cancelled_amount' => 'setCancelledAmount',
        'pending_invoices' => 'setPendingInvoices',
        'pending_amount' => 'setPendingAmount',
        'dunning_invoices' => 'setDunningInvoices',
        'dunning_amount' => 'setDunningAmount',
        'settled_invoices' => 'setSettledInvoices',
        'settled_amount' => 'setSettledAmount',
        'refunded_amount' => 'setRefundedAmount',
        'pending_additional_costs' => 'setPendingAdditionalCosts',
        'pending_additional_cost_amount' => 'setPendingAdditionalCostAmount',
        'transferred_additional_costs' => 'setTransferredAdditionalCosts',
        'transferred_additional_cost_amount' => 'setTransferredAdditionalCostAmount',
        'pending_credits' => 'setPendingCredits',
        'pending_credit_amount' => 'setPendingCreditAmount',
        'transferred_credits' => 'setTransferredCredits',
        'transferred_credit_amount' => 'setTransferredCreditAmount',
        'hosted_page_links' => 'setHostedPageLinks',
        'subscription_discounts' => 'setSubscriptionDiscounts',
        'pending_change' => 'setPendingChange',
        'subscription_changes' => 'setSubscriptionChanges',
        'subscription_add_ons' => 'setSubscriptionAddOns',
        'active_payment_methods' => 'setActivePaymentMethods'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'handle' => 'getHandle',
        'customer' => 'getCustomer',
        'plan' => 'getPlan',
        'state' => 'getState',
        'test' => 'getTest',
        'amount' => 'getAmount',
        'quantity' => 'getQuantity',
        'expires' => 'getExpires',
        'reactivated' => 'getReactivated',
        'timezone' => 'getTimezone',
        'created' => 'getCreated',
        'activated' => 'getActivated',
        'renewing' => 'getRenewing',
        'coupons' => 'getCoupons',
        'currency' => 'getCurrency',
        'plan_version' => 'getPlanVersion',
        'amount_incl_vat' => 'getAmountInclVat',
        'start_date' => 'getStartDate',
        'end_date' => 'getEndDate',
        'grace_duration' => 'getGraceDuration',
        'current_period_start' => 'getCurrentPeriodStart',
        'next_period_start' => 'getNextPeriodStart',
        'first_period_start' => 'getFirstPeriodStart',
        'last_period_start' => 'getLastPeriodStart',
        'trial_start' => 'getTrialStart',
        'trial_end' => 'getTrialEnd',
        'is_cancelled' => 'getIsCancelled',
        'in_trial' => 'getInTrial',
        'has_started' => 'getHasStarted',
        'renewal_count' => 'getRenewalCount',
        'cancelled_date' => 'getCancelledDate',
        'expired_date' => 'getExpiredDate',
        'expire_reason' => 'getExpireReason',
        'on_hold_date' => 'getOnHoldDate',
        'on_hold_reason' => 'getOnHoldReason',
        'payment_method_added' => 'getPaymentMethodAdded',
        'scheduled_plan_change' => 'getScheduledPlanChange',
        'reminder_email_sent' => 'getReminderEmailSent',
        'failed_invoices' => 'getFailedInvoices',
        'failed_amount' => 'getFailedAmount',
        'cancelled_invoices' => 'getCancelledInvoices',
        'cancelled_amount' => 'getCancelledAmount',
        'pending_invoices' => 'getPendingInvoices',
        'pending_amount' => 'getPendingAmount',
        'dunning_invoices' => 'getDunningInvoices',
        'dunning_amount' => 'getDunningAmount',
        'settled_invoices' => 'getSettledInvoices',
        'settled_amount' => 'getSettledAmount',
        'refunded_amount' => 'getRefundedAmount',
        'pending_additional_costs' => 'getPendingAdditionalCosts',
        'pending_additional_cost_amount' => 'getPendingAdditionalCostAmount',
        'transferred_additional_costs' => 'getTransferredAdditionalCosts',
        'transferred_additional_cost_amount' => 'getTransferredAdditionalCostAmount',
        'pending_credits' => 'getPendingCredits',
        'pending_credit_amount' => 'getPendingCreditAmount',
        'transferred_credits' => 'getTransferredCredits',
        'transferred_credit_amount' => 'getTransferredCreditAmount',
        'hosted_page_links' => 'getHostedPageLinks',
        'subscription_discounts' => 'getSubscriptionDiscounts',
        'pending_change' => 'getPendingChange',
        'subscription_changes' => 'getSubscriptionChanges',
        'subscription_add_ons' => 'getSubscriptionAddOns',
        'active_payment_methods' => 'getActivePaymentMethods'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATE_ACTIVE = 'active';
    const STATE_EXPIRED = 'expired';
    const STATE_ON_HOLD = 'on_hold';
    const STATE_PENDING = 'pending';
    const EXPIRE_REASON_DUNNING = 'dunning';
    const EXPIRE_REASON_CANCELLED = 'cancelled';
    const EXPIRE_REASON_ONDEMAND = 'ondemand';
    const EXPIRE_REASON_FIXED = 'fixed';
    const ON_HOLD_REASON_DUNNING = 'dunning';
    const ON_HOLD_REASON_ONDEMAND = 'ondemand';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
            self::STATE_EXPIRED,
            self::STATE_ON_HOLD,
            self::STATE_PENDING,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getExpireReasonAllowableValues()
    {
        return [
            self::EXPIRE_REASON_DUNNING,
            self::EXPIRE_REASON_CANCELLED,
            self::EXPIRE_REASON_ONDEMAND,
            self::EXPIRE_REASON_FIXED,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOnHoldReasonAllowableValues()
    {
        return [
            self::ON_HOLD_REASON_DUNNING,
            self::ON_HOLD_REASON_ONDEMAND,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['handle'] = isset($data['handle']) ? $data['handle'] : null;
        $this->container['customer'] = isset($data['customer']) ? $data['customer'] : null;
        $this->container['plan'] = isset($data['plan']) ? $data['plan'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['test'] = isset($data['test']) ? $data['test'] : null;
        $this->container['amount'] = isset($data['amount']) ? $data['amount'] : null;
        $this->container['quantity'] = isset($data['quantity']) ? $data['quantity'] : null;
        $this->container['expires'] = isset($data['expires']) ? $data['expires'] : null;
        $this->container['reactivated'] = isset($data['reactivated']) ? $data['reactivated'] : null;
        $this->container['timezone'] = isset($data['timezone']) ? $data['timezone'] : null;
        $this->container['created'] = isset($data['created']) ? $data['created'] : null;
        $this->container['activated'] = isset($data['activated']) ? $data['activated'] : null;
        $this->container['renewing'] = isset($data['renewing']) ? $data['renewing'] : null;
        $this->container['coupons'] = isset($data['coupons']) ? $data['coupons'] : null;
        $this->container['currency'] = isset($data['currency']) ? $data['currency'] : null;
        $this->container['plan_version'] = isset($data['plan_version']) ? $data['plan_version'] : null;
        $this->container['amount_incl_vat'] = isset($data['amount_incl_vat']) ? $data['amount_incl_vat'] : null;
        $this->container['start_date'] = isset($data['start_date']) ? $data['start_date'] : null;
        $this->container['end_date'] = isset($data['end_date']) ? $data['end_date'] : null;
        $this->container['grace_duration'] = isset($data['grace_duration']) ? $data['grace_duration'] : null;
        $this->container['current_period_start'] = isset($data['current_period_start']) ? $data['current_period_start'] : null;
        $this->container['next_period_start'] = isset($data['next_period_start']) ? $data['next_period_start'] : null;
        $this->container['first_period_start'] = isset($data['first_period_start']) ? $data['first_period_start'] : null;
        $this->container['last_period_start'] = isset($data['last_period_start']) ? $data['last_period_start'] : null;
        $this->container['trial_start'] = isset($data['trial_start']) ? $data['trial_start'] : null;
        $this->container['trial_end'] = isset($data['trial_end']) ? $data['trial_end'] : null;
        $this->container['is_cancelled'] = isset($data['is_cancelled']) ? $data['is_cancelled'] : null;
        $this->container['in_trial'] = isset($data['in_trial']) ? $data['in_trial'] : null;
        $this->container['has_started'] = isset($data['has_started']) ? $data['has_started'] : null;
        $this->container['renewal_count'] = isset($data['renewal_count']) ? $data['renewal_count'] : null;
        $this->container['cancelled_date'] = isset($data['cancelled_date']) ? $data['cancelled_date'] : null;
        $this->container['expired_date'] = isset($data['expired_date']) ? $data['expired_date'] : null;
        $this->container['expire_reason'] = isset($data['expire_reason']) ? $data['expire_reason'] : null;
        $this->container['on_hold_date'] = isset($data['on_hold_date']) ? $data['on_hold_date'] : null;
        $this->container['on_hold_reason'] = isset($data['on_hold_reason']) ? $data['on_hold_reason'] : null;
        $this->container['payment_method_added'] = isset($data['payment_method_added']) ? $data['payment_method_added'] : null;
        $this->container['scheduled_plan_change'] = isset($data['scheduled_plan_change']) ? $data['scheduled_plan_change'] : null;
        $this->container['reminder_email_sent'] = isset($data['reminder_email_sent']) ? $data['reminder_email_sent'] : null;
        $this->container['failed_invoices'] = isset($data['failed_invoices']) ? $data['failed_invoices'] : null;
        $this->container['failed_amount'] = isset($data['failed_amount']) ? $data['failed_amount'] : null;
        $this->container['cancelled_invoices'] = isset($data['cancelled_invoices']) ? $data['cancelled_invoices'] : null;
        $this->container['cancelled_amount'] = isset($data['cancelled_amount']) ? $data['cancelled_amount'] : null;
        $this->container['pending_invoices'] = isset($data['pending_invoices']) ? $data['pending_invoices'] : null;
        $this->container['pending_amount'] = isset($data['pending_amount']) ? $data['pending_amount'] : null;
        $this->container['dunning_invoices'] = isset($data['dunning_invoices']) ? $data['dunning_invoices'] : null;
        $this->container['dunning_amount'] = isset($data['dunning_amount']) ? $data['dunning_amount'] : null;
        $this->container['settled_invoices'] = isset($data['settled_invoices']) ? $data['settled_invoices'] : null;
        $this->container['settled_amount'] = isset($data['settled_amount']) ? $data['settled_amount'] : null;
        $this->container['refunded_amount'] = isset($data['refunded_amount']) ? $data['refunded_amount'] : null;
        $this->container['pending_additional_costs'] = isset($data['pending_additional_costs']) ? $data['pending_additional_costs'] : null;
        $this->container['pending_additional_cost_amount'] = isset($data['pending_additional_cost_amount']) ? $data['pending_additional_cost_amount'] : null;
        $this->container['transferred_additional_costs'] = isset($data['transferred_additional_costs']) ? $data['transferred_additional_costs'] : null;
        $this->container['transferred_additional_cost_amount'] = isset($data['transferred_additional_cost_amount']) ? $data['transferred_additional_cost_amount'] : null;
        $this->container['pending_credits'] = isset($data['pending_credits']) ? $data['pending_credits'] : null;
        $this->container['pending_credit_amount'] = isset($data['pending_credit_amount']) ? $data['pending_credit_amount'] : null;
        $this->container['transferred_credits'] = isset($data['transferred_credits']) ? $data['transferred_credits'] : null;
        $this->container['transferred_credit_amount'] = isset($data['transferred_credit_amount']) ? $data['transferred_credit_amount'] : null;
        $this->container['hosted_page_links'] = isset($data['hosted_page_links']) ? $data['hosted_page_links'] : null;
        $this->container['subscription_discounts'] = isset($data['subscription_discounts']) ? $data['subscription_discounts'] : null;
        $this->container['pending_change'] = isset($data['pending_change']) ? $data['pending_change'] : null;
        $this->container['subscription_changes'] = isset($data['subscription_changes']) ? $data['subscription_changes'] : null;
        $this->container['subscription_add_ons'] = isset($data['subscription_add_ons']) ? $data['subscription_add_ons'] : null;
        $this->container['active_payment_methods'] = isset($data['active_payment_methods']) ? $data['active_payment_methods'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ($this->container['customer'] === null) {
            $invalidProperties[] = "'customer' can't be null";
        }
        if ($this->container['plan'] === null) {
            $invalidProperties[] = "'plan' can't be null";
        }
        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['test'] === null) {
            $invalidProperties[] = "'test' can't be null";
        }
        if ($this->container['quantity'] === null) {
            $invalidProperties[] = "'quantity' can't be null";
        }
        if ($this->container['timezone'] === null) {
            $invalidProperties[] = "'timezone' can't be null";
        }
        if ($this->container['created'] === null) {
            $invalidProperties[] = "'created' can't be null";
        }
        if ($this->container['renewing'] === null) {
            $invalidProperties[] = "'renewing' can't be null";
        }
        if ($this->container['currency'] === null) {
            $invalidProperties[] = "'currency' can't be null";
        }
        if ($this->container['plan_version'] === null) {
            $invalidProperties[] = "'plan_version' can't be null";
        }
        if ($this->container['start_date'] === null) {
            $invalidProperties[] = "'start_date' can't be null";
        }
        if ($this->container['is_cancelled'] === null) {
            $invalidProperties[] = "'is_cancelled' can't be null";
        }
        if ($this->container['in_trial'] === null) {
            $invalidProperties[] = "'in_trial' can't be null";
        }
        if ($this->container['has_started'] === null) {
            $invalidProperties[] = "'has_started' can't be null";
        }
        if ($this->container['renewal_count'] === null) {
            $invalidProperties[] = "'renewal_count' can't be null";
        }
        $allowedValues = $this->getExpireReasonAllowableValues();
        if (!is_null($this->container['expire_reason']) && !in_array($this->container['expire_reason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'expire_reason', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getOnHoldReasonAllowableValues();
        if (!is_null($this->container['on_hold_reason']) && !in_array($this->container['on_hold_reason'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'on_hold_reason', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['payment_method_added'] === null) {
            $invalidProperties[] = "'payment_method_added' can't be null";
        }
        if ($this->container['failed_invoices'] === null) {
            $invalidProperties[] = "'failed_invoices' can't be null";
        }
        if ($this->container['failed_amount'] === null) {
            $invalidProperties[] = "'failed_amount' can't be null";
        }
        if ($this->container['cancelled_invoices'] === null) {
            $invalidProperties[] = "'cancelled_invoices' can't be null";
        }
        if ($this->container['cancelled_amount'] === null) {
            $invalidProperties[] = "'cancelled_amount' can't be null";
        }
        if ($this->container['pending_invoices'] === null) {
            $invalidProperties[] = "'pending_invoices' can't be null";
        }
        if ($this->container['pending_amount'] === null) {
            $invalidProperties[] = "'pending_amount' can't be null";
        }
        if ($this->container['dunning_invoices'] === null) {
            $invalidProperties[] = "'dunning_invoices' can't be null";
        }
        if ($this->container['dunning_amount'] === null) {
            $invalidProperties[] = "'dunning_amount' can't be null";
        }
        if ($this->container['settled_invoices'] === null) {
            $invalidProperties[] = "'settled_invoices' can't be null";
        }
        if ($this->container['settled_amount'] === null) {
            $invalidProperties[] = "'settled_amount' can't be null";
        }
        if ($this->container['refunded_amount'] === null) {
            $invalidProperties[] = "'refunded_amount' can't be null";
        }
        if ($this->container['pending_additional_costs'] === null) {
            $invalidProperties[] = "'pending_additional_costs' can't be null";
        }
        if ($this->container['pending_additional_cost_amount'] === null) {
            $invalidProperties[] = "'pending_additional_cost_amount' can't be null";
        }
        if ($this->container['transferred_additional_costs'] === null) {
            $invalidProperties[] = "'transferred_additional_costs' can't be null";
        }
        if ($this->container['transferred_additional_cost_amount'] === null) {
            $invalidProperties[] = "'transferred_additional_cost_amount' can't be null";
        }
        if ($this->container['pending_credits'] === null) {
            $invalidProperties[] = "'pending_credits' can't be null";
        }
        if ($this->container['pending_credit_amount'] === null) {
            $invalidProperties[] = "'pending_credit_amount' can't be null";
        }
        if ($this->container['transferred_credits'] === null) {
            $invalidProperties[] = "'transferred_credits' can't be null";
        }
        if ($this->container['transferred_credit_amount'] === null) {
            $invalidProperties[] = "'transferred_credit_amount' can't be null";
        }
        if ($this->container['hosted_page_links'] === null) {
            $invalidProperties[] = "'hosted_page_links' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique handle for subscription
     *
     * @return $this
     */
    public function setHandle($handle)
    {
        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets customer
     *
     * @return string
     */
    public function getCustomer()
    {
        return $this->container['customer'];
    }

    /**
     * Sets customer
     *
     * @param string $customer Customer handle
     *
     * @return $this
     */
    public function setCustomer($customer)
    {
        $this->container['customer'] = $customer;

        return $this;
    }

    /**
     * Gets plan
     *
     * @return string
     */
    public function getPlan()
    {
        return $this->container['plan'];
    }

    /**
     * Sets plan
     *
     * @param string $plan Subscription plan handle
     *
     * @return $this
     */
    public function setPlan($plan)
    {
        $this->container['plan'] = $plan;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the subscription, one of the following: `active`, `expired`, `on_hold` or `pending`. Active subscriptions can be cancelled and will expire at the end of the current billing period, or later depending on optional notice and fixation periods, this can be checked using the `is_cancelled` parameter and `expires`.
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets test
     *
     * @return bool
     */
    public function getTest()
    {
        return $this->container['test'];
    }

    /**
     * Sets test
     *
     * @param bool $test Test flag
     *
     * @return $this
     */
    public function setTest($test)
    {
        $this->container['test'] = $test;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int $amount Optional custom plan price. If defined the plan price billed for each billing period will be overridden by this price.
     *
     * @return $this
     */
    public function setAmount($amount)
    {
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int $quantity Quantity of the plan product for this subscription.
     *
     * @return $this
     */
    public function setQuantity($quantity)
    {
        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets expires
     *
     * @return \DateTime
     */
    public function getExpires()
    {
        return $this->container['expires'];
    }

    /**
     * Sets expires
     *
     * @param \DateTime $expires Fixed date when the subscription will expire because of cancellation. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setExpires($expires)
    {
        $this->container['expires'] = $expires;

        return $this;
    }

    /**
     * Gets reactivated
     *
     * @return \DateTime
     */
    public function getReactivated()
    {
        return $this->container['reactivated'];
    }

    /**
     * Sets reactivated
     *
     * @param \DateTime $reactivated Date when the subscription was reactivated from on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setReactivated($reactivated)
    {
        $this->container['reactivated'] = $reactivated;

        return $this;
    }

    /**
     * Gets timezone
     *
     * @return string
     */
    public function getTimezone()
    {
        return $this->container['timezone'];
    }

    /**
     * Sets timezone
     *
     * @param string $timezone Time zone for the subscription as standard time zone id. See [Wikipedia](http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
     *
     * @return $this
     */
    public function setTimezone($timezone)
    {
        $this->container['timezone'] = $timezone;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Date when the subscription was created. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setCreated($created)
    {
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets activated
     *
     * @return \DateTime
     */
    public function getActivated()
    {
        return $this->container['activated'];
    }

    /**
     * Sets activated
     *
     * @param \DateTime $activated Date when the subscription was activated. Will only differ from created in a two step prepared -> activated subscription create scenario. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setActivated($activated)
    {
        $this->container['activated'] = $activated;

        return $this;
    }

    /**
     * Gets renewing
     *
     * @return bool
     */
    public function getRenewing()
    {
        return $this->container['renewing'];
    }

    /**
     * Sets renewing
     *
     * @param bool $renewing If the subscription renews at current period end. Also true for subscriptions with manual scheduling.
     *
     * @return $this
     */
    public function setRenewing($renewing)
    {
        $this->container['renewing'] = $renewing;

        return $this;
    }

    /**
     * Gets coupons
     *
     * @return string[]
     */
    public function getCoupons()
    {
        return $this->container['coupons'];
    }

    /**
     * Sets coupons
     *
     * @param string[] $coupons List of coupon handles redeemed for the subscription
     *
     * @return $this
     */
    public function setCoupons($coupons)
    {
        $this->container['coupons'] = $coupons;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Currency for the subscription in [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) three letter alpha code
     *
     * @return $this
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets plan_version
     *
     * @return int
     */
    public function getPlanVersion()
    {
        return $this->container['plan_version'];
    }

    /**
     * Sets plan_version
     *
     * @param int $plan_version Subscription plan version
     *
     * @return $this
     */
    public function setPlanVersion($plan_version)
    {
        $this->container['plan_version'] = $plan_version;

        return $this;
    }

    /**
     * Gets amount_incl_vat
     *
     * @return bool
     */
    public function getAmountInclVat()
    {
        return $this->container['amount_incl_vat'];
    }

    /**
     * Sets amount_incl_vat
     *
     * @param bool $amount_incl_vat If optional custom plan price this parameter tells whether the amount is including VAT
     *
     * @return $this
     */
    public function setAmountInclVat($amount_incl_vat)
    {
        $this->container['amount_incl_vat'] = $amount_incl_vat;

        return $this;
    }

    /**
     * Gets start_date
     *
     * @return \DateTime
     */
    public function getStartDate()
    {
        return $this->container['start_date'];
    }

    /**
     * Sets start_date
     *
     * @param \DateTime $start_date Date and time from which the subscription is eligible to schedule invoices. Either from create or from the latest reactivate or subscription change. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setStartDate($start_date)
    {
        $this->container['start_date'] = $start_date;

        return $this;
    }

    /**
     * Gets end_date
     *
     * @return \DateTime
     */
    public function getEndDate()
    {
        return $this->container['end_date'];
    }

    /**
     * Sets end_date
     *
     * @param \DateTime $end_date Fixed end date and time. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setEndDate($end_date)
    {
        $this->container['end_date'] = $end_date;

        return $this;
    }

    /**
     * Gets grace_duration
     *
     * @return int
     */
    public function getGraceDuration()
    {
        return $this->container['grace_duration'];
    }

    /**
     * Sets grace_duration
     *
     * @param int $grace_duration Grace duration in seconds from the creation of a subscription where no dunning process is started for a failing invoice. This allows a certain amount of time for the customer to sign up with a payment method.
     *
     * @return $this
     */
    public function setGraceDuration($grace_duration)
    {
        $this->container['grace_duration'] = $grace_duration;

        return $this;
    }

    /**
     * Gets current_period_start
     *
     * @return \DateTime
     */
    public function getCurrentPeriodStart()
    {
        return $this->container['current_period_start'];
    }

    /**
     * Sets current_period_start
     *
     * @param \DateTime $current_period_start Start date and time for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setCurrentPeriodStart($current_period_start)
    {
        $this->container['current_period_start'] = $current_period_start;

        return $this;
    }

    /**
     * Gets next_period_start
     *
     * @return \DateTime
     */
    public function getNextPeriodStart()
    {
        return $this->container['next_period_start'];
    }

    /**
     * Sets next_period_start
     *
     * @param \DateTime $next_period_start Start date and time for the next billing period, and also end date and time for the current billing period. Is also the date and time for next invoice if the subscription is renewing. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setNextPeriodStart($next_period_start)
    {
        $this->container['next_period_start'] = $next_period_start;

        return $this;
    }

    /**
     * Gets first_period_start
     *
     * @return \DateTime
     */
    public function getFirstPeriodStart()
    {
        return $this->container['first_period_start'];
    }

    /**
     * Sets first_period_start
     *
     * @param \DateTime $first_period_start Start date and time for the first ever billing period. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setFirstPeriodStart($first_period_start)
    {
        $this->container['first_period_start'] = $first_period_start;

        return $this;
    }

    /**
     * Gets last_period_start
     *
     * @return \DateTime
     */
    public function getLastPeriodStart()
    {
        return $this->container['last_period_start'];
    }

    /**
     * Sets last_period_start
     *
     * @param \DateTime $last_period_start Start date and time for the previous billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setLastPeriodStart($last_period_start)
    {
        $this->container['last_period_start'] = $last_period_start;

        return $this;
    }

    /**
     * Gets trial_start
     *
     * @return \DateTime
     */
    public function getTrialStart()
    {
        return $this->container['trial_start'];
    }

    /**
     * Sets trial_start
     *
     * @param \DateTime $trial_start Start date and time of free trial period. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setTrialStart($trial_start)
    {
        $this->container['trial_start'] = $trial_start;

        return $this;
    }

    /**
     * Gets trial_end
     *
     * @return \DateTime
     */
    public function getTrialEnd()
    {
        return $this->container['trial_end'];
    }

    /**
     * Sets trial_end
     *
     * @param \DateTime $trial_end End date and time of free trial period. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setTrialEnd($trial_end)
    {
        $this->container['trial_end'] = $trial_end;

        return $this;
    }

    /**
     * Gets is_cancelled
     *
     * @return bool
     */
    public function getIsCancelled()
    {
        return $this->container['is_cancelled'];
    }

    /**
     * Sets is_cancelled
     *
     * @param bool $is_cancelled Whether the subscription has been cancelled. Cancelled subscriptions will expire at the end of the current billing period.
     *
     * @return $this
     */
    public function setIsCancelled($is_cancelled)
    {
        $this->container['is_cancelled'] = $is_cancelled;

        return $this;
    }

    /**
     * Gets in_trial
     *
     * @return bool
     */
    public function getInTrial()
    {
        return $this->container['in_trial'];
    }

    /**
     * Sets in_trial
     *
     * @param bool $in_trial Whether the subscription is in its trial period, or if the subscription will start a trial period at a start date in the future. See `has_started` to determine if the actual trial period has started or not.
     *
     * @return $this
     */
    public function setInTrial($in_trial)
    {
        $this->container['in_trial'] = $in_trial;

        return $this;
    }

    /**
     * Gets has_started
     *
     * @return bool
     */
    public function getHasStarted()
    {
        return $this->container['has_started'];
    }

    /**
     * Sets has_started
     *
     * @param bool $has_started If subscription has a later start date, this parameter tells if the subscription has started. Use this in connection with state to determine if a subscription is active.
     *
     * @return $this
     */
    public function setHasStarted($has_started)
    {
        $this->container['has_started'] = $has_started;

        return $this;
    }

    /**
     * Gets renewal_count
     *
     * @return int
     */
    public function getRenewalCount()
    {
        return $this->container['renewal_count'];
    }

    /**
     * Sets renewal_count
     *
     * @param int $renewal_count Number of renewals for the subscription (number of invoices)
     *
     * @return $this
     */
    public function setRenewalCount($renewal_count)
    {
        $this->container['renewal_count'] = $renewal_count;

        return $this;
    }

    /**
     * Gets cancelled_date
     *
     * @return \DateTime
     */
    public function getCancelledDate()
    {
        return $this->container['cancelled_date'];
    }

    /**
     * Sets cancelled_date
     *
     * @param \DateTime $cancelled_date Date when the subscription was cancelled. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setCancelledDate($cancelled_date)
    {
        $this->container['cancelled_date'] = $cancelled_date;

        return $this;
    }

    /**
     * Gets expired_date
     *
     * @return \DateTime
     */
    public function getExpiredDate()
    {
        return $this->container['expired_date'];
    }

    /**
     * Sets expired_date
     *
     * @param \DateTime $expired_date Date when the subscription expired. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setExpiredDate($expired_date)
    {
        $this->container['expired_date'] = $expired_date;

        return $this;
    }

    /**
     * Gets expire_reason
     *
     * @return string
     */
    public function getExpireReason()
    {
        return $this->container['expire_reason'];
    }

    /**
     * Sets expire_reason
     *
     * @param string $expire_reason Reason for expire. Can be `ondemand`, `cancelled`, `dunning` or `fixed`
     *
     * @return $this
     */
    public function setExpireReason($expire_reason)
    {
        $allowedValues = $this->getExpireReasonAllowableValues();
        if (!is_null($expire_reason) && !in_array($expire_reason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'expire_reason', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['expire_reason'] = $expire_reason;

        return $this;
    }

    /**
     * Gets on_hold_date
     *
     * @return \DateTime
     */
    public function getOnHoldDate()
    {
        return $this->container['on_hold_date'];
    }

    /**
     * Sets on_hold_date
     *
     * @param \DateTime $on_hold_date Date when the subscription was put on hold. [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setOnHoldDate($on_hold_date)
    {
        $this->container['on_hold_date'] = $on_hold_date;

        return $this;
    }

    /**
     * Gets on_hold_reason
     *
     * @return string
     */
    public function getOnHoldReason()
    {
        return $this->container['on_hold_reason'];
    }

    /**
     * Sets on_hold_reason
     *
     * @param string $on_hold_reason Reason for on hold. Can be `ondemand` or `dunning`
     *
     * @return $this
     */
    public function setOnHoldReason($on_hold_reason)
    {
        $allowedValues = $this->getOnHoldReasonAllowableValues();
        if (!is_null($on_hold_reason) && !in_array($on_hold_reason, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'on_hold_reason', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['on_hold_reason'] = $on_hold_reason;

        return $this;
    }

    /**
     * Gets payment_method_added
     *
     * @return bool
     */
    public function getPaymentMethodAdded()
    {
        return $this->container['payment_method_added'];
    }

    /**
     * Sets payment_method_added
     *
     * @param bool $payment_method_added Whether the customer at some point has added payment information to the subscription
     *
     * @return $this
     */
    public function setPaymentMethodAdded($payment_method_added)
    {
        $this->container['payment_method_added'] = $payment_method_added;

        return $this;
    }

    /**
     * Gets scheduled_plan_change
     *
     * @return string
     */
    public function getScheduledPlanChange()
    {
        return $this->container['scheduled_plan_change'];
    }

    /**
     * Sets scheduled_plan_change
     *
     * @param string $scheduled_plan_change Deprecated - see `pending_change`. If set, a subscription plan change has been scheduled to follow the next renewal. The value is the subscription plan handle to update to.
     *
     * @return $this
     */
    public function setScheduledPlanChange($scheduled_plan_change)
    {
        $this->container['scheduled_plan_change'] = $scheduled_plan_change;

        return $this;
    }

    /**
     * Gets reminder_email_sent
     *
     * @return \DateTime
     */
    public function getReminderEmailSent()
    {
        return $this->container['reminder_email_sent'];
    }

    /**
     * Sets reminder_email_sent
     *
     * @param \DateTime $reminder_email_sent If defined the date a reminder email was sent for the current billing period. In [ISO-8601](http://en.wikipedia.org/wiki/ISO_8601) extended offset date-time format.
     *
     * @return $this
     */
    public function setReminderEmailSent($reminder_email_sent)
    {
        $this->container['reminder_email_sent'] = $reminder_email_sent;

        return $this;
    }

    /**
     * Gets failed_invoices
     *
     * @return int
     */
    public function getFailedInvoices()
    {
        return $this->container['failed_invoices'];
    }

    /**
     * Sets failed_invoices
     *
     * @param int $failed_invoices Number of failed invoices for this subscription
     *
     * @return $this
     */
    public function setFailedInvoices($failed_invoices)
    {
        $this->container['failed_invoices'] = $failed_invoices;

        return $this;
    }

    /**
     * Gets failed_amount
     *
     * @return int
     */
    public function getFailedAmount()
    {
        return $this->container['failed_amount'];
    }

    /**
     * Sets failed_amount
     *
     * @param int $failed_amount Summed amount for failed invoices
     *
     * @return $this
     */
    public function setFailedAmount($failed_amount)
    {
        $this->container['failed_amount'] = $failed_amount;

        return $this;
    }

    /**
     * Gets cancelled_invoices
     *
     * @return int
     */
    public function getCancelledInvoices()
    {
        return $this->container['cancelled_invoices'];
    }

    /**
     * Sets cancelled_invoices
     *
     * @param int $cancelled_invoices Number of cancelled invoices for this subscription
     *
     * @return $this
     */
    public function setCancelledInvoices($cancelled_invoices)
    {
        $this->container['cancelled_invoices'] = $cancelled_invoices;

        return $this;
    }

    /**
     * Gets cancelled_amount
     *
     * @return int
     */
    public function getCancelledAmount()
    {
        return $this->container['cancelled_amount'];
    }

    /**
     * Sets cancelled_amount
     *
     * @param int $cancelled_amount Summed amount for cancelled invoices
     *
     * @return $this
     */
    public function setCancelledAmount($cancelled_amount)
    {
        $this->container['cancelled_amount'] = $cancelled_amount;

        return $this;
    }

    /**
     * Gets pending_invoices
     *
     * @return int
     */
    public function getPendingInvoices()
    {
        return $this->container['pending_invoices'];
    }

    /**
     * Sets pending_invoices
     *
     * @param int $pending_invoices Number of pending invoices for this subscription
     *
     * @return $this
     */
    public function setPendingInvoices($pending_invoices)
    {
        $this->container['pending_invoices'] = $pending_invoices;

        return $this;
    }

    /**
     * Gets pending_amount
     *
     * @return int
     */
    public function getPendingAmount()
    {
        return $this->container['pending_amount'];
    }

    /**
     * Sets pending_amount
     *
     * @param int $pending_amount Summed amount for pending invoices
     *
     * @return $this
     */
    public function setPendingAmount($pending_amount)
    {
        $this->container['pending_amount'] = $pending_amount;

        return $this;
    }

    /**
     * Gets dunning_invoices
     *
     * @return int
     */
    public function getDunningInvoices()
    {
        return $this->container['dunning_invoices'];
    }

    /**
     * Sets dunning_invoices
     *
     * @param int $dunning_invoices Number of dunning invoices for this subscription
     *
     * @return $this
     */
    public function setDunningInvoices($dunning_invoices)
    {
        $this->container['dunning_invoices'] = $dunning_invoices;

        return $this;
    }

    /**
     * Gets dunning_amount
     *
     * @return int
     */
    public function getDunningAmount()
    {
        return $this->container['dunning_amount'];
    }

    /**
     * Sets dunning_amount
     *
     * @param int $dunning_amount Summed amount for dunning invoices
     *
     * @return $this
     */
    public function setDunningAmount($dunning_amount)
    {
        $this->container['dunning_amount'] = $dunning_amount;

        return $this;
    }

    /**
     * Gets settled_invoices
     *
     * @return int
     */
    public function getSettledInvoices()
    {
        return $this->container['settled_invoices'];
    }

    /**
     * Sets settled_invoices
     *
     * @param int $settled_invoices Number of settled invoices for this subscription
     *
     * @return $this
     */
    public function setSettledInvoices($settled_invoices)
    {
        $this->container['settled_invoices'] = $settled_invoices;

        return $this;
    }

    /**
     * Gets settled_amount
     *
     * @return int
     */
    public function getSettledAmount()
    {
        return $this->container['settled_amount'];
    }

    /**
     * Sets settled_amount
     *
     * @param int $settled_amount Summed settled amount
     *
     * @return $this
     */
    public function setSettledAmount($settled_amount)
    {
        $this->container['settled_amount'] = $settled_amount;

        return $this;
    }

    /**
     * Gets refunded_amount
     *
     * @return int
     */
    public function getRefundedAmount()
    {
        return $this->container['refunded_amount'];
    }

    /**
     * Sets refunded_amount
     *
     * @param int $refunded_amount Summed refunded amount
     *
     * @return $this
     */
    public function setRefundedAmount($refunded_amount)
    {
        $this->container['refunded_amount'] = $refunded_amount;

        return $this;
    }

    /**
     * Gets pending_additional_costs
     *
     * @return int
     */
    public function getPendingAdditionalCosts()
    {
        return $this->container['pending_additional_costs'];
    }

    /**
     * Sets pending_additional_costs
     *
     * @param int $pending_additional_costs Number of pending additional costs
     *
     * @return $this
     */
    public function setPendingAdditionalCosts($pending_additional_costs)
    {
        $this->container['pending_additional_costs'] = $pending_additional_costs;

        return $this;
    }

    /**
     * Gets pending_additional_cost_amount
     *
     * @return int
     */
    public function getPendingAdditionalCostAmount()
    {
        return $this->container['pending_additional_cost_amount'];
    }

    /**
     * Sets pending_additional_cost_amount
     *
     * @param int $pending_additional_cost_amount Summed amount of pending additional costs incl vat
     *
     * @return $this
     */
    public function setPendingAdditionalCostAmount($pending_additional_cost_amount)
    {
        $this->container['pending_additional_cost_amount'] = $pending_additional_cost_amount;

        return $this;
    }

    /**
     * Gets transferred_additional_costs
     *
     * @return int
     */
    public function getTransferredAdditionalCosts()
    {
        return $this->container['transferred_additional_costs'];
    }

    /**
     * Sets transferred_additional_costs
     *
     * @param int $transferred_additional_costs Number of additional costs that have been applied to invoices
     *
     * @return $this
     */
    public function setTransferredAdditionalCosts($transferred_additional_costs)
    {
        $this->container['transferred_additional_costs'] = $transferred_additional_costs;

        return $this;
    }

    /**
     * Gets transferred_additional_cost_amount
     *
     * @return int
     */
    public function getTransferredAdditionalCostAmount()
    {
        return $this->container['transferred_additional_cost_amount'];
    }

    /**
     * Sets transferred_additional_cost_amount
     *
     * @param int $transferred_additional_cost_amount Summed amount of additional costs that have been applied to invoices
     *
     * @return $this
     */
    public function setTransferredAdditionalCostAmount($transferred_additional_cost_amount)
    {
        $this->container['transferred_additional_cost_amount'] = $transferred_additional_cost_amount;

        return $this;
    }

    /**
     * Gets pending_credits
     *
     * @return int
     */
    public function getPendingCredits()
    {
        return $this->container['pending_credits'];
    }

    /**
     * Sets pending_credits
     *
     * @param int $pending_credits Number of credits that have not fully been applied to invoices
     *
     * @return $this
     */
    public function setPendingCredits($pending_credits)
    {
        $this->container['pending_credits'] = $pending_credits;

        return $this;
    }

    /**
     * Gets pending_credit_amount
     *
     * @return int
     */
    public function getPendingCreditAmount()
    {
        return $this->container['pending_credit_amount'];
    }

    /**
     * Sets pending_credit_amount
     *
     * @param int $pending_credit_amount Summed credit amount not yet applied to invoices
     *
     * @return $this
     */
    public function setPendingCreditAmount($pending_credit_amount)
    {
        $this->container['pending_credit_amount'] = $pending_credit_amount;

        return $this;
    }

    /**
     * Gets transferred_credits
     *
     * @return int
     */
    public function getTransferredCredits()
    {
        return $this->container['transferred_credits'];
    }

    /**
     * Sets transferred_credits
     *
     * @param int $transferred_credits Number of credits that have fully been applied to invoices
     *
     * @return $this
     */
    public function setTransferredCredits($transferred_credits)
    {
        $this->container['transferred_credits'] = $transferred_credits;

        return $this;
    }

    /**
     * Gets transferred_credit_amount
     *
     * @return int
     */
    public function getTransferredCreditAmount()
    {
        return $this->container['transferred_credit_amount'];
    }

    /**
     * Sets transferred_credit_amount
     *
     * @param int $transferred_credit_amount Summed credit amount that have been applied to invoices
     *
     * @return $this
     */
    public function setTransferredCreditAmount($transferred_credit_amount)
    {
        $this->container['transferred_credit_amount'] = $transferred_credit_amount;

        return $this;
    }

    /**
     * Gets hosted_page_links
     *
     * @return \Reepay\Model\SubscriptionLinks
     */
    public function getHostedPageLinks()
    {
        return $this->container['hosted_page_links'];
    }

    /**
     * Sets hosted_page_links
     *
     * @param \Reepay\Model\SubscriptionLinks $hosted_page_links hosted_page_links
     *
     * @return $this
     */
    public function setHostedPageLinks($hosted_page_links)
    {
        $this->container['hosted_page_links'] = $hosted_page_links;

        return $this;
    }

    /**
     * Gets subscription_discounts
     *
     * @return string[]
     */
    public function getSubscriptionDiscounts()
    {
        return $this->container['subscription_discounts'];
    }

    /**
     * Sets subscription_discounts
     *
     * @param string[] $subscription_discounts List of subscription discounts handles attached to subscription
     *
     * @return $this
     */
    public function setSubscriptionDiscounts($subscription_discounts)
    {
        $this->container['subscription_discounts'] = $subscription_discounts;

        return $this;
    }

    /**
     * Gets pending_change
     *
     * @return \Reepay\Model\SubscriptionChange
     */
    public function getPendingChange()
    {
        return $this->container['pending_change'];
    }

    /**
     * Sets pending_change
     *
     * @param \Reepay\Model\SubscriptionChange $pending_change pending_change
     *
     * @return $this
     */
    public function setPendingChange($pending_change)
    {
        $this->container['pending_change'] = $pending_change;

        return $this;
    }

    /**
     * Gets subscription_changes
     *
     * @return \Reepay\Model\SubscriptionChange[]
     */
    public function getSubscriptionChanges()
    {
        return $this->container['subscription_changes'];
    }

    /**
     * Sets subscription_changes
     *
     * @param \Reepay\Model\SubscriptionChange[] $subscription_changes List of subscription changes both at most one pending and previously applied
     *
     * @return $this
     */
    public function setSubscriptionChanges($subscription_changes)
    {
        $this->container['subscription_changes'] = $subscription_changes;

        return $this;
    }

    /**
     * Gets subscription_add_ons
     *
     * @return string[]
     */
    public function getSubscriptionAddOns()
    {
        return $this->container['subscription_add_ons'];
    }

    /**
     * Sets subscription_add_ons
     *
     * @param string[] $subscription_add_ons List of subscription add-on handles attached to subscription
     *
     * @return $this
     */
    public function setSubscriptionAddOns($subscription_add_ons)
    {
        $this->container['subscription_add_ons'] = $subscription_add_ons;

        return $this;
    }

    /**
     * Gets active_payment_methods
     *
     * @return string[]
     */
    public function getActivePaymentMethods()
    {
        return $this->container['active_payment_methods'];
    }

    /**
     * Sets active_payment_methods
     *
     * @param string[] $active_payment_methods A list of active payment method ids. This list will at most contain 1 item.
     *
     * @return $this
     */
    public function setActivePaymentMethods($active_payment_methods)
    {
        $this->container['active_payment_methods'] = $active_payment_methods;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
