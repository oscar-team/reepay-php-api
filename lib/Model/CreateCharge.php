<?php
/**
 * CreateCharge
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * API
 *
 * REST API to manage Reepay resources
 *
 * OpenAPI spec version: 1
 * Contact: open.source@driveoscar.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * CreateCharge Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CreateCharge implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'CreateCharge';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'handle' => 'string',
        'key' => 'string',
        'amount' => 'int',
        'currency' => 'string',
        'customer' => '\Reepay\Model\CreateCustomer',
        'metadata' => 'map[string,object]',
        'source' => 'string',
        'settle' => 'bool',
        'recurring' => 'bool',
        'parameters' => '\Reepay\Model\ChargeParameters',
        'ordertext' => 'string',
        'order_lines' => '\Reepay\Model\CreateOrderLine[]',
        'customer_handle' => 'string',
        'billing_address' => '\Reepay\Model\InvoiceBillingAddress',
        'shipping_address' => '\Reepay\Model\InvoiceShippingAddress',
        'use_pm_for_subscription' => 'bool',
        'text_on_statement' => 'string',
        'payment_method_reference' => 'string',
        'async' => 'bool',
        'acquirer_reference' => 'string',
        'account_funding_information' => '\Reepay\Model\AccountFundingInformation',
        'account_funding' => 'bool'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'handle' => null,
        'key' => null,
        'amount' => 'int32',
        'currency' => null,
        'customer' => null,
        'metadata' => null,
        'source' => null,
        'settle' => null,
        'recurring' => null,
        'parameters' => null,
        'ordertext' => null,
        'order_lines' => null,
        'customer_handle' => null,
        'billing_address' => null,
        'shipping_address' => null,
        'use_pm_for_subscription' => null,
        'text_on_statement' => null,
        'payment_method_reference' => null,
        'async' => null,
        'acquirer_reference' => null,
        'account_funding_information' => null,
        'account_funding' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'handle' => 'handle',
        'key' => 'key',
        'amount' => 'amount',
        'currency' => 'currency',
        'customer' => 'customer',
        'metadata' => 'metadata',
        'source' => 'source',
        'settle' => 'settle',
        'recurring' => 'recurring',
        'parameters' => 'parameters',
        'ordertext' => 'ordertext',
        'order_lines' => 'order_lines',
        'customer_handle' => 'customer_handle',
        'billing_address' => 'billing_address',
        'shipping_address' => 'shipping_address',
        'use_pm_for_subscription' => 'use_pm_for_subscription',
        'text_on_statement' => 'text_on_statement',
        'payment_method_reference' => 'payment_method_reference',
        'async' => 'async',
        'acquirer_reference' => 'acquirer_reference',
        'account_funding_information' => 'account_funding_information',
        'account_funding' => 'account_funding'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'handle' => 'setHandle',
        'key' => 'setKey',
        'amount' => 'setAmount',
        'currency' => 'setCurrency',
        'customer' => 'setCustomer',
        'metadata' => 'setMetadata',
        'source' => 'setSource',
        'settle' => 'setSettle',
        'recurring' => 'setRecurring',
        'parameters' => 'setParameters',
        'ordertext' => 'setOrdertext',
        'order_lines' => 'setOrderLines',
        'customer_handle' => 'setCustomerHandle',
        'billing_address' => 'setBillingAddress',
        'shipping_address' => 'setShippingAddress',
        'use_pm_for_subscription' => 'setUsePmForSubscription',
        'text_on_statement' => 'setTextOnStatement',
        'payment_method_reference' => 'setPaymentMethodReference',
        'async' => 'setAsync',
        'acquirer_reference' => 'setAcquirerReference',
        'account_funding_information' => 'setAccountFundingInformation',
        'account_funding' => 'setAccountFunding'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'handle' => 'getHandle',
        'key' => 'getKey',
        'amount' => 'getAmount',
        'currency' => 'getCurrency',
        'customer' => 'getCustomer',
        'metadata' => 'getMetadata',
        'source' => 'getSource',
        'settle' => 'getSettle',
        'recurring' => 'getRecurring',
        'parameters' => 'getParameters',
        'ordertext' => 'getOrdertext',
        'order_lines' => 'getOrderLines',
        'customer_handle' => 'getCustomerHandle',
        'billing_address' => 'getBillingAddress',
        'shipping_address' => 'getShippingAddress',
        'use_pm_for_subscription' => 'getUsePmForSubscription',
        'text_on_statement' => 'getTextOnStatement',
        'payment_method_reference' => 'getPaymentMethodReference',
        'async' => 'getAsync',
        'acquirer_reference' => 'getAcquirerReference',
        'account_funding_information' => 'getAccountFundingInformation',
        'account_funding' => 'getAccountFunding'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }



    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['handle'] = isset($data['handle']) ? $data['handle'] : null;
        $this->container['key'] = isset($data['key']) ? $data['key'] : null;
        $this->container['amount'] = isset($data['amount']) ? $data['amount'] : null;
        $this->container['currency'] = isset($data['currency']) ? $data['currency'] : null;
        $this->container['customer'] = isset($data['customer']) ? $data['customer'] : null;
        $this->container['metadata'] = isset($data['metadata']) ? $data['metadata'] : null;
        $this->container['source'] = isset($data['source']) ? $data['source'] : null;
        $this->container['settle'] = isset($data['settle']) ? $data['settle'] : null;
        $this->container['recurring'] = isset($data['recurring']) ? $data['recurring'] : null;
        $this->container['parameters'] = isset($data['parameters']) ? $data['parameters'] : null;
        $this->container['ordertext'] = isset($data['ordertext']) ? $data['ordertext'] : null;
        $this->container['order_lines'] = isset($data['order_lines']) ? $data['order_lines'] : null;
        $this->container['customer_handle'] = isset($data['customer_handle']) ? $data['customer_handle'] : null;
        $this->container['billing_address'] = isset($data['billing_address']) ? $data['billing_address'] : null;
        $this->container['shipping_address'] = isset($data['shipping_address']) ? $data['shipping_address'] : null;
        $this->container['use_pm_for_subscription'] = isset($data['use_pm_for_subscription']) ? $data['use_pm_for_subscription'] : null;
        $this->container['text_on_statement'] = isset($data['text_on_statement']) ? $data['text_on_statement'] : null;
        $this->container['payment_method_reference'] = isset($data['payment_method_reference']) ? $data['payment_method_reference'] : null;
        $this->container['async'] = isset($data['async']) ? $data['async'] : null;
        $this->container['acquirer_reference'] = isset($data['acquirer_reference']) ? $data['acquirer_reference'] : null;
        $this->container['account_funding_information'] = isset($data['account_funding_information']) ? $data['account_funding_information'] : null;
        $this->container['account_funding'] = isset($data['account_funding']) ? $data['account_funding'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ($this->container['source'] === null) {
            $invalidProperties[] = "'source' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique reference to charge/invoice. E.g. order id from own system. Multiple payments can be attempted for the same handle but only one authorized or settled charge can exist per handle. Max length 255 with allowable characters [a-zA-Z0-9_.-@]. It is recommended to use a maximum of 20 characters as this will allow for the use of handle as reference on bank statements without truncation.
     *
     * @return $this
     */
    public function setHandle($handle)
    {
        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets key
     *
     * @return string
     */
    public function getKey()
    {
        return $this->container['key'];
    }

    /**
     * Sets key
     *
     * @param string $key Optional idempotency key. Only one authorization or settle can be performed for the same handle. If two create attempts are attempted and the first succeeds the second will fail because charge is already settled or authorized. An idempotency key identifies uniquely the request and multiple requests with the same key and handle will yield the same result. In case of networking errors the same request with same key can safely be retried.
     *
     * @return $this
     */
    public function setKey($key)
    {
        $this->container['key'] = $key;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int $amount Amount in the smallest unit. Either `amount` or `order_lines` must be provided if charge/invoice does not already exists.
     *
     * @return $this
     */
    public function setAmount($amount)
    {
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Optional currency in [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) three letter alpha code. If not provided the account default currency will be used. The currency of an existing charge or invoice cannot be changed.
     *
     * @return $this
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets customer
     *
     * @return \Reepay\Model\CreateCustomer
     */
    public function getCustomer()
    {
        return $this->container['customer'];
    }

    /**
     * Sets customer
     *
     * @param \Reepay\Model\CreateCustomer $customer customer
     *
     * @return $this
     */
    public function setCustomer($customer)
    {
        $this->container['customer'] = $customer;

        return $this;
    }

    /**
     * Gets metadata
     *
     * @return map[string,object]
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param map[string,object] $metadata Custom metadata.
     *
     * @return $this
     */
    public function setMetadata($metadata)
    {
        $this->container['metadata'] = $metadata;

        return $this;
    }

    /**
     * Gets source
     *
     * @return string
     */
    public function getSource()
    {
        return $this->container['source'];
    }

    /**
     * Sets source
     *
     * @param string $source The source for the payment. Either an existing payment method for the customer or a card token `ct_...`. The existing payment method can either be referenced directly with id, e.g. `ca_...`, or the keyword `auto` can be given to indicate that the newest active customer payment method should be used.
     *
     * @return $this
     */
    public function setSource($source)
    {
        $this->container['source'] = $source;

        return $this;
    }

    /**
     * Gets settle
     *
     * @return bool
     */
    public function getSettle()
    {
        return $this->container['settle'];
    }

    /**
     * Sets settle
     *
     * @param bool $settle Whether or not to immediately settle the charge. If not settled immediately the charge will be authorized and can later be settled. Normally this have to be done within 7 days. The default is not to settle the charge immediately. Note that not all payment methods support immediate settle.
     *
     * @return $this
     */
    public function setSettle($settle)
    {
        $this->container['settle'] = $settle;

        return $this;
    }

    /**
     * Gets recurring
     *
     * @return bool
     */
    public function getRecurring()
    {
        return $this->container['recurring'];
    }

    /**
     * Sets recurring
     *
     * @param bool $recurring If set and the source is a token for a payment method that supports recurring charging (e.g. credit card), a recurring payment method is stored for the customer and a reference returned.
     *
     * @return $this
     */
    public function setRecurring($recurring)
    {
        $this->container['recurring'] = $recurring;

        return $this;
    }

    /**
     * Gets parameters
     *
     * @return \Reepay\Model\ChargeParameters
     */
    public function getParameters()
    {
        return $this->container['parameters'];
    }

    /**
     * Sets parameters
     *
     * @param \Reepay\Model\ChargeParameters $parameters parameters
     *
     * @return $this
     */
    public function setParameters($parameters)
    {
        $this->container['parameters'] = $parameters;

        return $this;
    }

    /**
     * Gets ordertext
     *
     * @return string
     */
    public function getOrdertext()
    {
        return $this->container['ordertext'];
    }

    /**
     * Sets ordertext
     *
     * @param string $ordertext Optional order text. Used in conjunction with `amount`. Ignored if `order_lines` is provided.
     *
     * @return $this
     */
    public function setOrdertext($ordertext)
    {
        $this->container['ordertext'] = $ordertext;

        return $this;
    }

    /**
     * Gets order_lines
     *
     * @return \Reepay\Model\CreateOrderLine[]
     */
    public function getOrderLines()
    {
        return $this->container['order_lines'];
    }

    /**
     * Sets order_lines
     *
     * @param \Reepay\Model\CreateOrderLine[] $order_lines Order lines for the charge. The order lines controls the amount. Only required if charge/invoice does not already exist. If given for existing charge the order lines and amount are adjusted. A maximum of 100 order lines is allowed.
     *
     * @return $this
     */
    public function setOrderLines($order_lines)
    {
        $this->container['order_lines'] = $order_lines;

        return $this;
    }

    /**
     * Gets customer_handle
     *
     * @return string
     */
    public function getCustomerHandle()
    {
        return $this->container['customer_handle'];
    }

    /**
     * Sets customer_handle
     *
     * @param string $customer_handle Customer reference. If charge does not already exist either this reference must be provided, a create customer object must be provided or the source must be a payment method reference (e.g. `ca_..`) identifying customer. Notice that customer cannot be changed for existing charge/invoice so if handle is provided it must match the customer handle for existing customer.
     *
     * @return $this
     */
    public function setCustomerHandle($customer_handle)
    {
        $this->container['customer_handle'] = $customer_handle;

        return $this;
    }

    /**
     * Gets billing_address
     *
     * @return \Reepay\Model\InvoiceBillingAddress
     */
    public function getBillingAddress()
    {
        return $this->container['billing_address'];
    }

    /**
     * Sets billing_address
     *
     * @param \Reepay\Model\InvoiceBillingAddress $billing_address billing_address
     *
     * @return $this
     */
    public function setBillingAddress($billing_address)
    {
        $this->container['billing_address'] = $billing_address;

        return $this;
    }

    /**
     * Gets shipping_address
     *
     * @return \Reepay\Model\InvoiceShippingAddress
     */
    public function getShippingAddress()
    {
        return $this->container['shipping_address'];
    }

    /**
     * Sets shipping_address
     *
     * @param \Reepay\Model\InvoiceShippingAddress $shipping_address shipping_address
     *
     * @return $this
     */
    public function setShippingAddress($shipping_address)
    {
        $this->container['shipping_address'] = $shipping_address;

        return $this;
    }

    /**
     * Gets use_pm_for_subscription
     *
     * @return bool
     */
    public function getUsePmForSubscription()
    {
        return $this->container['use_pm_for_subscription'];
    }

    /**
     * Sets use_pm_for_subscription
     *
     * @param bool $use_pm_for_subscription When used with a subscription invoice the subscription payment method will be updated. If the subscription is pending the subscription will be activated with the payment method. The recurring argument is set to true.
     *
     * @return $this
     */
    public function setUsePmForSubscription($use_pm_for_subscription)
    {
        $this->container['use_pm_for_subscription'] = $use_pm_for_subscription;

        return $this;
    }

    /**
     * Gets text_on_statement
     *
     * @return string
     */
    public function getTextOnStatement()
    {
        return $this->container['text_on_statement'];
    }

    /**
     * Sets text_on_statement
     *
     * @param string $text_on_statement Optional argument to define the text on bank statement. Notice the following about this argument: 1. It only works for some acquirers. 2. Acquirers may have rigid rules on the content of the text on statement. Not complying to these rules will result in declined payments. 3) It is already possible to define custom text on statement using templating in the Reepay Administration. Contact support for help. We highly recommend to only supply this argument if absolutely necessary, and the templated default text on statement is not sufficient. Maximum length is 128, but most acquirers require a maximum length of 22 characters. Truncating will be applied if too long for specific acquirer. Characters must match regex `[\\x20-\\x7F]`
     *
     * @return $this
     */
    public function setTextOnStatement($text_on_statement)
    {
        $this->container['text_on_statement'] = $text_on_statement;

        return $this;
    }

    /**
     * Gets payment_method_reference
     *
     * @return string
     */
    public function getPaymentMethodReference()
    {
        return $this->container['payment_method_reference'];
    }

    /**
     * Sets payment_method_reference
     *
     * @param string $payment_method_reference Optional reference given to the created payment method in case recurring argument is used to save payment method. Max length 64 with allowable characters [a-zA-Z0-9_.-@].
     *
     * @return $this
     */
    public function setPaymentMethodReference($payment_method_reference)
    {
        $this->container['payment_method_reference'] = $payment_method_reference;

        return $this;
    }

    /**
     * Gets async
     *
     * @return bool
     */
    public function getAsync()
    {
        return $this->container['async'];
    }

    /**
     * Sets async
     *
     * @param bool $async For payment methods that supports both synchronous and asynchronous handling this parameter can be used force a specific handling. Asynchronous handling means that a pending state will be returned. The subsequent state change can be registered by using webhooks. The default depends on the payment method.
     *
     * @return $this
     */
    public function setAsync($async)
    {
        $this->container['async'] = $async;

        return $this;
    }

    /**
     * Gets acquirer_reference
     *
     * @return string
     */
    public function getAcquirerReference()
    {
        return $this->container['acquirer_reference'];
    }

    /**
     * Sets acquirer_reference
     *
     * @param string $acquirer_reference Optional reference for the transaction at the acquirer. Notice the following about this argument: 1. It only works for some acquirers. 2. Acquirers may have rigid rules on the content of the acquirer reference.  Not complying to these rules can result in declined payments. 3. It is already possible to define custom acquirer reference using templating in the Reepay Administration.  Contact support for help. We highly recommend to only supply this argument if absolutely necessary,  and the templated default acquirer reference is not sufficient. Maximum length is 128,  but most acquirers require a maximum length of 22 characters.  Truncating will be applied if too long for specific acquirer.  Characters must match regex `[\\x20-\\x7F]`
     *
     * @return $this
     */
    public function setAcquirerReference($acquirer_reference)
    {
        $this->container['acquirer_reference'] = $acquirer_reference;

        return $this;
    }

    /**
     * Gets account_funding_information
     *
     * @return \Reepay\Model\AccountFundingInformation
     */
    public function getAccountFundingInformation()
    {
        return $this->container['account_funding_information'];
    }

    /**
     * Sets account_funding_information
     *
     * @param \Reepay\Model\AccountFundingInformation $account_funding_information account_funding_information
     *
     * @return $this
     */
    public function setAccountFundingInformation($account_funding_information)
    {
        $this->container['account_funding_information'] = $account_funding_information;

        return $this;
    }

    /**
     * Gets account_funding
     *
     * @return bool
     */
    public function getAccountFunding()
    {
        return $this->container['account_funding'];
    }

    /**
     * Sets account_funding
     *
     * @param bool $account_funding Indicates that Account Funding Transaction (AFT) is requested. It only can be used for instant settle (i.e. 'settle' = true)
     *
     * @return $this
     */
    public function setAccountFunding($account_funding)
    {
        $this->container['account_funding'] = $account_funding;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
