<?php
/**
 * Plan
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Reepay Checkout API
 *
 * Reepay Checkout REST API
 *
 * OpenAPI spec version: 1
 * Contact: open.source@driveoscar.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * Plan Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class Plan implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'Plan';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'name' => 'string',
        'description' => 'string',
        'vat' => 'float',
        'amount' => 'int',
        'quantity' => 'int',
        'prepaid' => 'bool',
        'handle' => 'string',
        'version' => 'int',
        'state' => 'string',
        'currency' => 'string',
        'created' => '\DateTime',
        'deleted' => '\DateTime',
        'dunning_plan' => 'string',
        'tax_policy' => 'string',
        'renewal_reminder_email_days' => 'int',
        'trial_reminder_email_days' => 'int',
        'partial_period_handling' => 'string',
        'include_zero_amount' => 'bool',
        'setup_fee' => 'int',
        'setup_fee_text' => 'string',
        'setup_fee_handling' => 'string',
        'partial_proration_days' => 'bool',
        'fixed_trial_days' => 'bool',
        'minimum_prorated_amount' => 'int',
        'account_funding' => 'bool',
        'amount_incl_vat' => 'bool',
        'fixed_count' => 'int',
        'fixed_life_time_unit' => 'string',
        'fixed_life_time_length' => 'int',
        'trial_interval_unit' => 'string',
        'trial_interval_length' => 'int',
        'interval_length' => 'int',
        'schedule_type' => 'string',
        'schedule_fixed_day' => 'int',
        'base_month' => 'int',
        'notice_periods' => 'int',
        'notice_periods_after_current' => 'bool',
        'fixation_periods' => 'int',
        'fixation_periods_full' => 'bool',
        'entitlements' => 'string[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'name' => null,
        'description' => null,
        'vat' => 'float',
        'amount' => 'int32',
        'quantity' => 'int32',
        'prepaid' => null,
        'handle' => null,
        'version' => 'int32',
        'state' => null,
        'currency' => null,
        'created' => 'date-time',
        'deleted' => 'date-time',
        'dunning_plan' => null,
        'tax_policy' => null,
        'renewal_reminder_email_days' => 'int32',
        'trial_reminder_email_days' => 'int32',
        'partial_period_handling' => null,
        'include_zero_amount' => null,
        'setup_fee' => 'int32',
        'setup_fee_text' => null,
        'setup_fee_handling' => null,
        'partial_proration_days' => null,
        'fixed_trial_days' => null,
        'minimum_prorated_amount' => 'int32',
        'account_funding' => null,
        'amount_incl_vat' => null,
        'fixed_count' => 'int32',
        'fixed_life_time_unit' => null,
        'fixed_life_time_length' => 'int32',
        'trial_interval_unit' => null,
        'trial_interval_length' => 'int32',
        'interval_length' => 'int32',
        'schedule_type' => null,
        'schedule_fixed_day' => 'int32',
        'base_month' => 'int32',
        'notice_periods' => 'int32',
        'notice_periods_after_current' => null,
        'fixation_periods' => 'int32',
        'fixation_periods_full' => null,
        'entitlements' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'description' => 'description',
        'vat' => 'vat',
        'amount' => 'amount',
        'quantity' => 'quantity',
        'prepaid' => 'prepaid',
        'handle' => 'handle',
        'version' => 'version',
        'state' => 'state',
        'currency' => 'currency',
        'created' => 'created',
        'deleted' => 'deleted',
        'dunning_plan' => 'dunning_plan',
        'tax_policy' => 'tax_policy',
        'renewal_reminder_email_days' => 'renewal_reminder_email_days',
        'trial_reminder_email_days' => 'trial_reminder_email_days',
        'partial_period_handling' => 'partial_period_handling',
        'include_zero_amount' => 'include_zero_amount',
        'setup_fee' => 'setup_fee',
        'setup_fee_text' => 'setup_fee_text',
        'setup_fee_handling' => 'setup_fee_handling',
        'partial_proration_days' => 'partial_proration_days',
        'fixed_trial_days' => 'fixed_trial_days',
        'minimum_prorated_amount' => 'minimum_prorated_amount',
        'account_funding' => 'account_funding',
        'amount_incl_vat' => 'amount_incl_vat',
        'fixed_count' => 'fixed_count',
        'fixed_life_time_unit' => 'fixed_life_time_unit',
        'fixed_life_time_length' => 'fixed_life_time_length',
        'trial_interval_unit' => 'trial_interval_unit',
        'trial_interval_length' => 'trial_interval_length',
        'interval_length' => 'interval_length',
        'schedule_type' => 'schedule_type',
        'schedule_fixed_day' => 'schedule_fixed_day',
        'base_month' => 'base_month',
        'notice_periods' => 'notice_periods',
        'notice_periods_after_current' => 'notice_periods_after_current',
        'fixation_periods' => 'fixation_periods',
        'fixation_periods_full' => 'fixation_periods_full',
        'entitlements' => 'entitlements'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'description' => 'setDescription',
        'vat' => 'setVat',
        'amount' => 'setAmount',
        'quantity' => 'setQuantity',
        'prepaid' => 'setPrepaid',
        'handle' => 'setHandle',
        'version' => 'setVersion',
        'state' => 'setState',
        'currency' => 'setCurrency',
        'created' => 'setCreated',
        'deleted' => 'setDeleted',
        'dunning_plan' => 'setDunningPlan',
        'tax_policy' => 'setTaxPolicy',
        'renewal_reminder_email_days' => 'setRenewalReminderEmailDays',
        'trial_reminder_email_days' => 'setTrialReminderEmailDays',
        'partial_period_handling' => 'setPartialPeriodHandling',
        'include_zero_amount' => 'setIncludeZeroAmount',
        'setup_fee' => 'setSetupFee',
        'setup_fee_text' => 'setSetupFeeText',
        'setup_fee_handling' => 'setSetupFeeHandling',
        'partial_proration_days' => 'setPartialProrationDays',
        'fixed_trial_days' => 'setFixedTrialDays',
        'minimum_prorated_amount' => 'setMinimumProratedAmount',
        'account_funding' => 'setAccountFunding',
        'amount_incl_vat' => 'setAmountInclVat',
        'fixed_count' => 'setFixedCount',
        'fixed_life_time_unit' => 'setFixedLifeTimeUnit',
        'fixed_life_time_length' => 'setFixedLifeTimeLength',
        'trial_interval_unit' => 'setTrialIntervalUnit',
        'trial_interval_length' => 'setTrialIntervalLength',
        'interval_length' => 'setIntervalLength',
        'schedule_type' => 'setScheduleType',
        'schedule_fixed_day' => 'setScheduleFixedDay',
        'base_month' => 'setBaseMonth',
        'notice_periods' => 'setNoticePeriods',
        'notice_periods_after_current' => 'setNoticePeriodsAfterCurrent',
        'fixation_periods' => 'setFixationPeriods',
        'fixation_periods_full' => 'setFixationPeriodsFull',
        'entitlements' => 'setEntitlements'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'description' => 'getDescription',
        'vat' => 'getVat',
        'amount' => 'getAmount',
        'quantity' => 'getQuantity',
        'prepaid' => 'getPrepaid',
        'handle' => 'getHandle',
        'version' => 'getVersion',
        'state' => 'getState',
        'currency' => 'getCurrency',
        'created' => 'getCreated',
        'deleted' => 'getDeleted',
        'dunning_plan' => 'getDunningPlan',
        'tax_policy' => 'getTaxPolicy',
        'renewal_reminder_email_days' => 'getRenewalReminderEmailDays',
        'trial_reminder_email_days' => 'getTrialReminderEmailDays',
        'partial_period_handling' => 'getPartialPeriodHandling',
        'include_zero_amount' => 'getIncludeZeroAmount',
        'setup_fee' => 'getSetupFee',
        'setup_fee_text' => 'getSetupFeeText',
        'setup_fee_handling' => 'getSetupFeeHandling',
        'partial_proration_days' => 'getPartialProrationDays',
        'fixed_trial_days' => 'getFixedTrialDays',
        'minimum_prorated_amount' => 'getMinimumProratedAmount',
        'account_funding' => 'getAccountFunding',
        'amount_incl_vat' => 'getAmountInclVat',
        'fixed_count' => 'getFixedCount',
        'fixed_life_time_unit' => 'getFixedLifeTimeUnit',
        'fixed_life_time_length' => 'getFixedLifeTimeLength',
        'trial_interval_unit' => 'getTrialIntervalUnit',
        'trial_interval_length' => 'getTrialIntervalLength',
        'interval_length' => 'getIntervalLength',
        'schedule_type' => 'getScheduleType',
        'schedule_fixed_day' => 'getScheduleFixedDay',
        'base_month' => 'getBaseMonth',
        'notice_periods' => 'getNoticePeriods',
        'notice_periods_after_current' => 'getNoticePeriodsAfterCurrent',
        'fixation_periods' => 'getFixationPeriods',
        'fixation_periods_full' => 'getFixationPeriodsFull',
        'entitlements' => 'getEntitlements'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const STATE_ACTIVE = 'active';
    const STATE_SUPERSEDED = 'superseded';
    const STATE_DELETED = 'deleted';
    const PARTIAL_PERIOD_HANDLING_BILL_FULL = 'bill_full';
    const PARTIAL_PERIOD_HANDLING_BILL_PRORATED = 'bill_prorated';
    const PARTIAL_PERIOD_HANDLING_BILL_ZERO_AMOUNT = 'bill_zero_amount';
    const PARTIAL_PERIOD_HANDLING_NO_BILL = 'no_bill';
    const FIXED_LIFE_TIME_UNIT_MONTHS = 'months';
    const FIXED_LIFE_TIME_UNIT_DAYS = 'days';
    const TRIAL_INTERVAL_UNIT_MONTHS = 'months';
    const TRIAL_INTERVAL_UNIT_DAYS = 'days';
    const SCHEDULE_TYPE_MANUAL = 'manual';
    const SCHEDULE_TYPE_DAILY = 'daily';
    const SCHEDULE_TYPE_WEEKLY_FIXEDDAY = 'weekly_fixedday';
    const SCHEDULE_TYPE_MONTH_STARTDATE = 'month_startdate';
    const SCHEDULE_TYPE_MONTH_FIXEDDAY = 'month_fixedday';
    const SCHEDULE_TYPE_MONTH_LASTDAY = 'month_lastday';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
            self::STATE_SUPERSEDED,
            self::STATE_DELETED,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPartialPeriodHandlingAllowableValues()
    {
        return [
            self::PARTIAL_PERIOD_HANDLING_BILL_FULL,
            self::PARTIAL_PERIOD_HANDLING_BILL_PRORATED,
            self::PARTIAL_PERIOD_HANDLING_BILL_ZERO_AMOUNT,
            self::PARTIAL_PERIOD_HANDLING_NO_BILL,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getFixedLifeTimeUnitAllowableValues()
    {
        return [
            self::FIXED_LIFE_TIME_UNIT_MONTHS,
            self::FIXED_LIFE_TIME_UNIT_DAYS,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTrialIntervalUnitAllowableValues()
    {
        return [
            self::TRIAL_INTERVAL_UNIT_MONTHS,
            self::TRIAL_INTERVAL_UNIT_DAYS,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScheduleTypeAllowableValues()
    {
        return [
            self::SCHEDULE_TYPE_MANUAL,
            self::SCHEDULE_TYPE_DAILY,
            self::SCHEDULE_TYPE_WEEKLY_FIXEDDAY,
            self::SCHEDULE_TYPE_MONTH_STARTDATE,
            self::SCHEDULE_TYPE_MONTH_FIXEDDAY,
            self::SCHEDULE_TYPE_MONTH_LASTDAY,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['vat'] = isset($data['vat']) ? $data['vat'] : null;
        $this->container['amount'] = isset($data['amount']) ? $data['amount'] : null;
        $this->container['quantity'] = isset($data['quantity']) ? $data['quantity'] : null;
        $this->container['prepaid'] = isset($data['prepaid']) ? $data['prepaid'] : null;
        $this->container['handle'] = isset($data['handle']) ? $data['handle'] : null;
        $this->container['version'] = isset($data['version']) ? $data['version'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['currency'] = isset($data['currency']) ? $data['currency'] : null;
        $this->container['created'] = isset($data['created']) ? $data['created'] : null;
        $this->container['deleted'] = isset($data['deleted']) ? $data['deleted'] : null;
        $this->container['dunning_plan'] = isset($data['dunning_plan']) ? $data['dunning_plan'] : null;
        $this->container['tax_policy'] = isset($data['tax_policy']) ? $data['tax_policy'] : null;
        $this->container['renewal_reminder_email_days'] = isset($data['renewal_reminder_email_days']) ? $data['renewal_reminder_email_days'] : null;
        $this->container['trial_reminder_email_days'] = isset($data['trial_reminder_email_days']) ? $data['trial_reminder_email_days'] : null;
        $this->container['partial_period_handling'] = isset($data['partial_period_handling']) ? $data['partial_period_handling'] : null;
        $this->container['include_zero_amount'] = isset($data['include_zero_amount']) ? $data['include_zero_amount'] : null;
        $this->container['setup_fee'] = isset($data['setup_fee']) ? $data['setup_fee'] : null;
        $this->container['setup_fee_text'] = isset($data['setup_fee_text']) ? $data['setup_fee_text'] : null;
        $this->container['setup_fee_handling'] = isset($data['setup_fee_handling']) ? $data['setup_fee_handling'] : null;
        $this->container['partial_proration_days'] = isset($data['partial_proration_days']) ? $data['partial_proration_days'] : null;
        $this->container['fixed_trial_days'] = isset($data['fixed_trial_days']) ? $data['fixed_trial_days'] : null;
        $this->container['minimum_prorated_amount'] = isset($data['minimum_prorated_amount']) ? $data['minimum_prorated_amount'] : null;
        $this->container['account_funding'] = isset($data['account_funding']) ? $data['account_funding'] : null;
        $this->container['amount_incl_vat'] = isset($data['amount_incl_vat']) ? $data['amount_incl_vat'] : null;
        $this->container['fixed_count'] = isset($data['fixed_count']) ? $data['fixed_count'] : null;
        $this->container['fixed_life_time_unit'] = isset($data['fixed_life_time_unit']) ? $data['fixed_life_time_unit'] : null;
        $this->container['fixed_life_time_length'] = isset($data['fixed_life_time_length']) ? $data['fixed_life_time_length'] : null;
        $this->container['trial_interval_unit'] = isset($data['trial_interval_unit']) ? $data['trial_interval_unit'] : null;
        $this->container['trial_interval_length'] = isset($data['trial_interval_length']) ? $data['trial_interval_length'] : null;
        $this->container['interval_length'] = isset($data['interval_length']) ? $data['interval_length'] : null;
        $this->container['schedule_type'] = isset($data['schedule_type']) ? $data['schedule_type'] : null;
        $this->container['schedule_fixed_day'] = isset($data['schedule_fixed_day']) ? $data['schedule_fixed_day'] : null;
        $this->container['base_month'] = isset($data['base_month']) ? $data['base_month'] : null;
        $this->container['notice_periods'] = isset($data['notice_periods']) ? $data['notice_periods'] : null;
        $this->container['notice_periods_after_current'] = isset($data['notice_periods_after_current']) ? $data['notice_periods_after_current'] : null;
        $this->container['fixation_periods'] = isset($data['fixation_periods']) ? $data['fixation_periods'] : null;
        $this->container['fixation_periods_full'] = isset($data['fixation_periods_full']) ? $data['fixation_periods_full'] : null;
        $this->container['entitlements'] = isset($data['entitlements']) ? $data['entitlements'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['name'] === null) {
            $invalidProperties[] = "'name' can't be null";
        }
        if ($this->container['amount'] === null) {
            $invalidProperties[] = "'amount' can't be null";
        }
        if ($this->container['handle'] === null) {
            $invalidProperties[] = "'handle' can't be null";
        }
        if ($this->container['version'] === null) {
            $invalidProperties[] = "'version' can't be null";
        }
        if ($this->container['state'] === null) {
            $invalidProperties[] = "'state' can't be null";
        }
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['currency'] === null) {
            $invalidProperties[] = "'currency' can't be null";
        }
        if ($this->container['created'] === null) {
            $invalidProperties[] = "'created' can't be null";
        }
        $allowedValues = $this->getPartialPeriodHandlingAllowableValues();
        if (!is_null($this->container['partial_period_handling']) && !in_array($this->container['partial_period_handling'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'partial_period_handling', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getFixedLifeTimeUnitAllowableValues();
        if (!is_null($this->container['fixed_life_time_unit']) && !in_array($this->container['fixed_life_time_unit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'fixed_life_time_unit', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTrialIntervalUnitAllowableValues();
        if (!is_null($this->container['trial_interval_unit']) && !in_array($this->container['trial_interval_unit'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'trial_interval_unit', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['schedule_type'] === null) {
            $invalidProperties[] = "'schedule_type' can't be null";
        }
        $allowedValues = $this->getScheduleTypeAllowableValues();
        if (!is_null($this->container['schedule_type']) && !in_array($this->container['schedule_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'schedule_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Name of the plan
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description Description of the plan
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets vat
     *
     * @return float
     */
    public function getVat()
    {
        return $this->container['vat'];
    }

    /**
     * Sets vat
     *
     * @param float $vat Optional vat for this plan. Account default is used if none given.
     *
     * @return $this
     */
    public function setVat($vat)
    {
        $this->container['vat'] = $vat;

        return $this;
    }

    /**
     * Gets amount
     *
     * @return int
     */
    public function getAmount()
    {
        return $this->container['amount'];
    }

    /**
     * Sets amount
     *
     * @param int $amount Amount for the plan in the smallest unit for the account currency
     *
     * @return $this
     */
    public function setAmount($amount)
    {
        $this->container['amount'] = $amount;

        return $this;
    }

    /**
     * Gets quantity
     *
     * @return int
     */
    public function getQuantity()
    {
        return $this->container['quantity'];
    }

    /**
     * Sets quantity
     *
     * @param int $quantity Optional default quantity of the subscription plan product for new subscriptions. Default is 1.
     *
     * @return $this
     */
    public function setQuantity($quantity)
    {
        $this->container['quantity'] = $quantity;

        return $this;
    }

    /**
     * Gets prepaid
     *
     * @return bool
     */
    public function getPrepaid()
    {
        return $this->container['prepaid'];
    }

    /**
     * Sets prepaid
     *
     * @param bool $prepaid Subscriptions can either be prepaid where an amount is paid in advance, or the opposite. This setting only relates to handling of pause scenarios.
     *
     * @return $this
     */
    public function setPrepaid($prepaid)
    {
        $this->container['prepaid'] = $prepaid;

        return $this;
    }

    /**
     * Gets handle
     *
     * @return string
     */
    public function getHandle()
    {
        return $this->container['handle'];
    }

    /**
     * Sets handle
     *
     * @param string $handle Per account unique handle for the subscription plan. Max length 255 with allowable characters [a-zA-Z0-9_.-@].
     *
     * @return $this
     */
    public function setHandle($handle)
    {
        $this->container['handle'] = $handle;

        return $this;
    }

    /**
     * Gets version
     *
     * @return int
     */
    public function getVersion()
    {
        return $this->container['version'];
    }

    /**
     * Sets version
     *
     * @param int $version Plan version
     *
     * @return $this
     */
    public function setVersion($version)
    {
        $this->container['version'] = $version;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the subscription plan one of the following: `active`, `superseded`, `deleted`
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string $currency Currency for the subscription plan in [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) three letter alpha code
     *
     * @return $this
     */
    public function setCurrency($currency)
    {
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Date when the subscription plan was created. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setCreated($created)
    {
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets deleted
     *
     * @return \DateTime
     */
    public function getDeleted()
    {
        return $this->container['deleted'];
    }

    /**
     * Sets deleted
     *
     * @param \DateTime $deleted Date when the subscription plan was deleted. In ISO-8601 extended offset date-time format.
     *
     * @return $this
     */
    public function setDeleted($deleted)
    {
        $this->container['deleted'] = $deleted;

        return $this;
    }

    /**
     * Gets dunning_plan
     *
     * @return string
     */
    public function getDunningPlan()
    {
        return $this->container['dunning_plan'];
    }

    /**
     * Sets dunning_plan
     *
     * @param string $dunning_plan Dunning plan by handle to use for the subscription plan. Default dunning plan will be used if none given.
     *
     * @return $this
     */
    public function setDunningPlan($dunning_plan)
    {
        $this->container['dunning_plan'] = $dunning_plan;

        return $this;
    }

    /**
     * Gets tax_policy
     *
     * @return string
     */
    public function getTaxPolicy()
    {
        return $this->container['tax_policy'];
    }

    /**
     * Sets tax_policy
     *
     * @param string $tax_policy Optional tax policy handle for this plan. If vat and tax policy is given, vat will be ignored.
     *
     * @return $this
     */
    public function setTaxPolicy($tax_policy)
    {
        $this->container['tax_policy'] = $tax_policy;

        return $this;
    }

    /**
     * Gets renewal_reminder_email_days
     *
     * @return int
     */
    public function getRenewalReminderEmailDays()
    {
        return $this->container['renewal_reminder_email_days'];
    }

    /**
     * Sets renewal_reminder_email_days
     *
     * @param int $renewal_reminder_email_days Optional renewal reminder email settings. Number of days before next billing to send a reminder email.
     *
     * @return $this
     */
    public function setRenewalReminderEmailDays($renewal_reminder_email_days)
    {
        $this->container['renewal_reminder_email_days'] = $renewal_reminder_email_days;

        return $this;
    }

    /**
     * Gets trial_reminder_email_days
     *
     * @return int
     */
    public function getTrialReminderEmailDays()
    {
        return $this->container['trial_reminder_email_days'];
    }

    /**
     * Sets trial_reminder_email_days
     *
     * @param int $trial_reminder_email_days Optional end of trial reminder email settings. Number of days before end of trial to send a reminder email.
     *
     * @return $this
     */
    public function setTrialReminderEmailDays($trial_reminder_email_days)
    {
        $this->container['trial_reminder_email_days'] = $trial_reminder_email_days;

        return $this;
    }

    /**
     * Gets partial_period_handling
     *
     * @return string
     */
    public function getPartialPeriodHandling()
    {
        return $this->container['partial_period_handling'];
    }

    /**
     * Sets partial_period_handling
     *
     * @param string $partial_period_handling How to handle a potential initial partial billing period for fixed day scheduling. The options are to bill for a full period, bill prorated for the partial period, bill a zero amoumt, or not to consider the period before first fixed day a billing period. The default is to bill prorated. Options: `bill_full`, `bill_prorated`, `bill_zero_amount`, `no_bill`.
     *
     * @return $this
     */
    public function setPartialPeriodHandling($partial_period_handling)
    {
        $allowedValues = $this->getPartialPeriodHandlingAllowableValues();
        if (!is_null($partial_period_handling) && !in_array($partial_period_handling, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'partial_period_handling', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['partial_period_handling'] = $partial_period_handling;

        return $this;
    }

    /**
     * Gets include_zero_amount
     *
     * @return bool
     */
    public function getIncludeZeroAmount()
    {
        return $this->container['include_zero_amount'];
    }

    /**
     * Sets include_zero_amount
     *
     * @param bool $include_zero_amount Whether to add a zero amount order line to subscription invoices if plan amount is zero or the subscription overrides to zero amount. The default is to not include the line. If no other order lines are present the plan order line will be added.
     *
     * @return $this
     */
    public function setIncludeZeroAmount($include_zero_amount)
    {
        $this->container['include_zero_amount'] = $include_zero_amount;

        return $this;
    }

    /**
     * Gets setup_fee
     *
     * @return int
     */
    public function getSetupFee()
    {
        return $this->container['setup_fee'];
    }

    /**
     * Sets setup_fee
     *
     * @param int $setup_fee Optional one-time setup fee billed with the first invoice or as a separate invoice depending on the setting `setup_fee_handling`.
     *
     * @return $this
     */
    public function setSetupFee($setup_fee)
    {
        $this->container['setup_fee'] = $setup_fee;

        return $this;
    }

    /**
     * Gets setup_fee_text
     *
     * @return string
     */
    public function getSetupFeeText()
    {
        return $this->container['setup_fee_text'];
    }

    /**
     * Sets setup_fee_text
     *
     * @param string $setup_fee_text Optional invoice order text for the setup fee that
     *
     * @return $this
     */
    public function setSetupFeeText($setup_fee_text)
    {
        $this->container['setup_fee_text'] = $setup_fee_text;

        return $this;
    }

    /**
     * Gets setup_fee_handling
     *
     * @return string
     */
    public function getSetupFeeHandling()
    {
        return $this->container['setup_fee_handling'];
    }

    /**
     * Sets setup_fee_handling
     *
     * @param string $setup_fee_handling How the billing of the setup fee should be done. The options are: `first` - include setup fee as order line on the first scheduled invoice. `separate` - create a separate invoice for the setup fee, is appropriate if first invoice is not in conjunction with creation. `separate_conditional` - create a separate invoice for setup fee if the first invoice is not created in conjunction with the creation. Default is `first`.
     *
     * @return $this
     */
    public function setSetupFeeHandling($setup_fee_handling)
    {
        $this->container['setup_fee_handling'] = $setup_fee_handling;

        return $this;
    }

    /**
     * Gets partial_proration_days
     *
     * @return bool
     */
    public function getPartialProrationDays()
    {
        return $this->container['partial_proration_days'];
    }

    /**
     * Sets partial_proration_days
     *
     * @param bool $partial_proration_days For fixed day scheduling and prorated partial handling calculate prorated amount using whole days counting start day as a full day, or use by the minute proration calculation from start date time to the next period start. Default is true (whole days).
     *
     * @return $this
     */
    public function setPartialProrationDays($partial_proration_days)
    {
        $this->container['partial_proration_days'] = $partial_proration_days;

        return $this;
    }

    /**
     * Gets fixed_trial_days
     *
     * @return bool
     */
    public function getFixedTrialDays()
    {
        return $this->container['fixed_trial_days'];
    }

    /**
     * Sets fixed_trial_days
     *
     * @param bool $fixed_trial_days When using trial for fixed day scheduling use this setting to control if trial expires at midnight or the trial period is down to the minute. Default is true (trial until start of day). Trial in days can only be true if `partial_proration_days` is also set to true.
     *
     * @return $this
     */
    public function setFixedTrialDays($fixed_trial_days)
    {
        $this->container['fixed_trial_days'] = $fixed_trial_days;

        return $this;
    }

    /**
     * Gets minimum_prorated_amount
     *
     * @return int
     */
    public function getMinimumProratedAmount()
    {
        return $this->container['minimum_prorated_amount'];
    }

    /**
     * Sets minimum_prorated_amount
     *
     * @param int $minimum_prorated_amount When using prorated partial handling the prorated amount for plan and add-ons might result in very small amounts. A minimum prorated amount for plan and add-ons can be defined. If the prorated amount is below this minimum the amount will be changed to zero.
     *
     * @return $this
     */
    public function setMinimumProratedAmount($minimum_prorated_amount)
    {
        $this->container['minimum_prorated_amount'] = $minimum_prorated_amount;

        return $this;
    }

    /**
     * Gets account_funding
     *
     * @return bool
     */
    public function getAccountFunding()
    {
        return $this->container['account_funding'];
    }

    /**
     * Sets account_funding
     *
     * @param bool $account_funding Indicates that Account Funding Transaction (AFT) is requested.
     *
     * @return $this
     */
    public function setAccountFunding($account_funding)
    {
        $this->container['account_funding'] = $account_funding;

        return $this;
    }

    /**
     * Gets amount_incl_vat
     *
     * @return bool
     */
    public function getAmountInclVat()
    {
        return $this->container['amount_incl_vat'];
    }

    /**
     * Sets amount_incl_vat
     *
     * @param bool $amount_incl_vat Whether the amount is including VAT. Default true.
     *
     * @return $this
     */
    public function setAmountInclVat($amount_incl_vat)
    {
        $this->container['amount_incl_vat'] = $amount_incl_vat;

        return $this;
    }

    /**
     * Gets fixed_count
     *
     * @return int
     */
    public function getFixedCount()
    {
        return $this->container['fixed_count'];
    }

    /**
     * Sets fixed_count
     *
     * @param int $fixed_count Fixed number of renewals for subscriptions using this plan. Equals the number of scheduled invoices. Default is no fixed amount of renewals.
     *
     * @return $this
     */
    public function setFixedCount($fixed_count)
    {
        $this->container['fixed_count'] = $fixed_count;

        return $this;
    }

    /**
     * Gets fixed_life_time_unit
     *
     * @return string
     */
    public function getFixedLifeTimeUnit()
    {
        return $this->container['fixed_life_time_unit'];
    }

    /**
     * Sets fixed_life_time_unit
     *
     * @param string $fixed_life_time_unit Time unit use for fixed life time
     *
     * @return $this
     */
    public function setFixedLifeTimeUnit($fixed_life_time_unit)
    {
        $allowedValues = $this->getFixedLifeTimeUnitAllowableValues();
        if (!is_null($fixed_life_time_unit) && !in_array($fixed_life_time_unit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'fixed_life_time_unit', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['fixed_life_time_unit'] = $fixed_life_time_unit;

        return $this;
    }

    /**
     * Gets fixed_life_time_length
     *
     * @return int
     */
    public function getFixedLifeTimeLength()
    {
        return $this->container['fixed_life_time_length'];
    }

    /**
     * Sets fixed_life_time_length
     *
     * @param int $fixed_life_time_length Optional fixed life time length for subscriptions using this plan. E.g. 12 months. Subscriptions will cancel after the fixed life time and expire when the active billing cycle ends.
     *
     * @return $this
     */
    public function setFixedLifeTimeLength($fixed_life_time_length)
    {
        $this->container['fixed_life_time_length'] = $fixed_life_time_length;

        return $this;
    }

    /**
     * Gets trial_interval_unit
     *
     * @return string
     */
    public function getTrialIntervalUnit()
    {
        return $this->container['trial_interval_unit'];
    }

    /**
     * Sets trial_interval_unit
     *
     * @param string $trial_interval_unit Time unit for free trial period
     *
     * @return $this
     */
    public function setTrialIntervalUnit($trial_interval_unit)
    {
        $allowedValues = $this->getTrialIntervalUnitAllowableValues();
        if (!is_null($trial_interval_unit) && !in_array($trial_interval_unit, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'trial_interval_unit', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['trial_interval_unit'] = $trial_interval_unit;

        return $this;
    }

    /**
     * Gets trial_interval_length
     *
     * @return int
     */
    public function getTrialIntervalLength()
    {
        return $this->container['trial_interval_length'];
    }

    /**
     * Sets trial_interval_length
     *
     * @param int $trial_interval_length Optional free trial interval length. E.g. 1 monts.
     *
     * @return $this
     */
    public function setTrialIntervalLength($trial_interval_length)
    {
        $this->container['trial_interval_length'] = $trial_interval_length;

        return $this;
    }

    /**
     * Gets interval_length
     *
     * @return int
     */
    public function getIntervalLength()
    {
        return $this->container['interval_length'];
    }

    /**
     * Sets interval_length
     *
     * @param int $interval_length The length of intervals. E.g. every second month or every 14 days.
     *
     * @return $this
     */
    public function setIntervalLength($interval_length)
    {
        $this->container['interval_length'] = $interval_length;

        return $this;
    }

    /**
     * Gets schedule_type
     *
     * @return string
     */
    public function getScheduleType()
    {
        return $this->container['schedule_type'];
    }

    /**
     * Sets schedule_type
     *
     * @param string $schedule_type Scheduling type, one of the following: `manual`, `daily`, `weekly_fixedday`, `month_startdate`, `month_fixedday`, `month_lastday`. See documentation for descriptions of the different types.
     *
     * @return $this
     */
    public function setScheduleType($schedule_type)
    {
        $allowedValues = $this->getScheduleTypeAllowableValues();
        if (!in_array($schedule_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'schedule_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['schedule_type'] = $schedule_type;

        return $this;
    }

    /**
     * Gets schedule_fixed_day
     *
     * @return int
     */
    public function getScheduleFixedDay()
    {
        return $this->container['schedule_fixed_day'];
    }

    /**
     * Sets schedule_fixed_day
     *
     * @param int $schedule_fixed_day If a fixed day scheduling type is used a fixed day must be provided. For months the allowed value is 1-28 for weeks it is 1-7
     *
     * @return $this
     */
    public function setScheduleFixedDay($schedule_fixed_day)
    {
        $this->container['schedule_fixed_day'] = $schedule_fixed_day;

        return $this;
    }

    /**
     * Gets base_month
     *
     * @return int
     */
    public function getBaseMonth()
    {
        return $this->container['base_month'];
    }

    /**
     * Sets base_month
     *
     * @param int $base_month For fixed month schedule types the base month can be used to control which months are eligible for start of first billing period. The eligible months are calculated as `base_month + k * interval_length` up to 12. E.g. to use quaterly billing in the months jan-apr-jul-oct, `base_month` 1 and `interval_length` 3 can be used. If not defined the first fixed day will be used as start of first billing period.
     *
     * @return $this
     */
    public function setBaseMonth($base_month)
    {
        $this->container['base_month'] = $base_month;

        return $this;
    }

    /**
     * Gets notice_periods
     *
     * @return int
     */
    public function getNoticePeriods()
    {
        return $this->container['notice_periods'];
    }

    /**
     * Sets notice_periods
     *
     * @param int $notice_periods Optional number of notice periods for a cancel. The subscription will be cancelled for this number of full periods before expiring. Either from the cancellation date, or from the end of the the current period. See `notice_periods_after_current`. The default is to expire at the end of current period (0). A value of 1 (and `notice_periods_after_current` set to true) will for example result in a scenario where the subscription is cancelled until the end of current period, and then for the full subsequent period before expiring.
     *
     * @return $this
     */
    public function setNoticePeriods($notice_periods)
    {
        $this->container['notice_periods'] = $notice_periods;

        return $this;
    }

    /**
     * Gets notice_periods_after_current
     *
     * @return bool
     */
    public function getNoticePeriodsAfterCurrent()
    {
        return $this->container['notice_periods_after_current'];
    }

    /**
     * Sets notice_periods_after_current
     *
     * @param bool $notice_periods_after_current If notice periods is set, this option controls whether the number of full notice periods should start at the end of the current period, or run from cancellation date and result in a partial period with partial amount for the last period. The default is true. E.g. if set to false and `notice_periods = 1` then the subscription will be cancelled for exactly for one period from the cancellation time and a partial amount will be billed at the start of the next billing period.
     *
     * @return $this
     */
    public function setNoticePeriodsAfterCurrent($notice_periods_after_current)
    {
        $this->container['notice_periods_after_current'] = $notice_periods_after_current;

        return $this;
    }

    /**
     * Gets fixation_periods
     *
     * @return int
     */
    public function getFixationPeriods()
    {
        return $this->container['fixation_periods'];
    }

    /**
     * Sets fixation_periods
     *
     * @param int $fixation_periods Optional number of fixation periods. Fixation periods will guarantee that a subscription will have this number of paid full periods before expiring after a cancel. Default is to have no requirement (0).
     *
     * @return $this
     */
    public function setFixationPeriods($fixation_periods)
    {
        $this->container['fixation_periods'] = $fixation_periods;

        return $this;
    }

    /**
     * Gets fixation_periods_full
     *
     * @return bool
     */
    public function getFixationPeriodsFull()
    {
        return $this->container['fixation_periods_full'];
    }

    /**
     * Sets fixation_periods_full
     *
     * @param bool $fixation_periods_full If fixation periods are defined, and the subscription can have a partial prorated first period, this parameter controls if the the last period should be full, or partial to give exactly `fixation_periods` paid periods. Default is false.
     *
     * @return $this
     */
    public function setFixationPeriodsFull($fixation_periods_full)
    {
        $this->container['fixation_periods_full'] = $fixation_periods_full;

        return $this;
    }

    /**
     * Gets entitlements
     *
     * @return string[]
     */
    public function getEntitlements()
    {
        return $this->container['entitlements'];
    }

    /**
     * Sets entitlements
     *
     * @param string[] $entitlements Entitlements for the plan
     *
     * @return $this
     */
    public function setEntitlements($entitlements)
    {
        $this->container['entitlements'] = $entitlements;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
