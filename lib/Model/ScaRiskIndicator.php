<?php
/**
 * ScaRiskIndicator
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Reepay Checkout API
 *
 * Reepay Checkout REST API
 *
 * OpenAPI spec version: 1
 * Contact: open.source@driveoscar.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * ScaRiskIndicator Class Doc Comment
 *
 * @category Class
 * @description Optional argument to help the issuer in determining whether to use a frictionless authentication flow. The object represents the assessed level of fraud risk.
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ScaRiskIndicator implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ScaRiskIndicator';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'delivery_email' => 'string',
        'delivery_timeframe' => 'string',
        'gift_card_amount' => 'int',
        'gift_card_count' => 'int',
        'gift_card_currency' => 'string',
        'pre_order_date' => 'string',
        'pre_order_purchase_indicator' => 'string',
        'reorder_items_indicator' => 'string',
        'shipping_indicator' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'delivery_email' => null,
        'delivery_timeframe' => null,
        'gift_card_amount' => 'int32',
        'gift_card_count' => 'int32',
        'gift_card_currency' => null,
        'pre_order_date' => null,
        'pre_order_purchase_indicator' => null,
        'reorder_items_indicator' => null,
        'shipping_indicator' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'delivery_email' => 'delivery_email',
        'delivery_timeframe' => 'delivery_timeframe',
        'gift_card_amount' => 'gift_card_amount',
        'gift_card_count' => 'gift_card_count',
        'gift_card_currency' => 'gift_card_currency',
        'pre_order_date' => 'pre_order_date',
        'pre_order_purchase_indicator' => 'pre_order_purchase_indicator',
        'reorder_items_indicator' => 'reorder_items_indicator',
        'shipping_indicator' => 'shipping_indicator'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'delivery_email' => 'setDeliveryEmail',
        'delivery_timeframe' => 'setDeliveryTimeframe',
        'gift_card_amount' => 'setGiftCardAmount',
        'gift_card_count' => 'setGiftCardCount',
        'gift_card_currency' => 'setGiftCardCurrency',
        'pre_order_date' => 'setPreOrderDate',
        'pre_order_purchase_indicator' => 'setPreOrderPurchaseIndicator',
        'reorder_items_indicator' => 'setReorderItemsIndicator',
        'shipping_indicator' => 'setShippingIndicator'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'delivery_email' => 'getDeliveryEmail',
        'delivery_timeframe' => 'getDeliveryTimeframe',
        'gift_card_amount' => 'getGiftCardAmount',
        'gift_card_count' => 'getGiftCardCount',
        'gift_card_currency' => 'getGiftCardCurrency',
        'pre_order_date' => 'getPreOrderDate',
        'pre_order_purchase_indicator' => 'getPreOrderPurchaseIndicator',
        'reorder_items_indicator' => 'getReorderItemsIndicator',
        'shipping_indicator' => 'getShippingIndicator'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const DELIVERY_TIMEFRAME_ELECTRONIC = 'electronic';
    const DELIVERY_TIMEFRAME_SAME_DAY_SHIPPING = 'same_day_shipping';
    const DELIVERY_TIMEFRAME_OVERNIGHT_SHIPPING = 'overnight_shipping';
    const DELIVERY_TIMEFRAME_TWO_DAY_OR_MORE_SHIPPING = 'two_day_or_more_shipping';
    const PRE_ORDER_PURCHASE_INDICATOR_MERCHANDISE_AVAILABLE = 'merchandise_available';
    const PRE_ORDER_PURCHASE_INDICATOR_FUTURE_AVAILABILITY = 'future_availability';
    const REORDER_ITEMS_INDICATOR_FIRST_TIME_ORDERED = 'first_time_ordered';
    const REORDER_ITEMS_INDICATOR_REORDERED = 'reordered';
    const SHIPPING_INDICATOR_BILLING_ADDRESS = 'billing_address';
    const SHIPPING_INDICATOR_VERIFIED = 'verified';
    const SHIPPING_INDICATOR_NON_BILLING_ADDRESS = 'non_billing_address';
    const SHIPPING_INDICATOR_SHIP_TO_STORE = 'ship_to_store';
    const SHIPPING_INDICATOR_DIGITAL_GOODS = 'digital_goods';
    const SHIPPING_INDICATOR_TRAVEL_AND_EVENT_TICKETS = 'travel_and_event_tickets';
    const SHIPPING_INDICATOR_OTHER = 'other';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDeliveryTimeframeAllowableValues()
    {
        return [
            self::DELIVERY_TIMEFRAME_ELECTRONIC,
            self::DELIVERY_TIMEFRAME_SAME_DAY_SHIPPING,
            self::DELIVERY_TIMEFRAME_OVERNIGHT_SHIPPING,
            self::DELIVERY_TIMEFRAME_TWO_DAY_OR_MORE_SHIPPING,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getPreOrderPurchaseIndicatorAllowableValues()
    {
        return [
            self::PRE_ORDER_PURCHASE_INDICATOR_MERCHANDISE_AVAILABLE,
            self::PRE_ORDER_PURCHASE_INDICATOR_FUTURE_AVAILABILITY,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getReorderItemsIndicatorAllowableValues()
    {
        return [
            self::REORDER_ITEMS_INDICATOR_FIRST_TIME_ORDERED,
            self::REORDER_ITEMS_INDICATOR_REORDERED,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getShippingIndicatorAllowableValues()
    {
        return [
            self::SHIPPING_INDICATOR_BILLING_ADDRESS
            self::SHIPPING_INDICATOR_VERIFIED
            self::SHIPPING_INDICATOR_NON_BILLING_ADDRESS
            self::SHIPPING_INDICATOR_SHIP_TO_STORE
            self::SHIPPING_INDICATOR_DIGITAL_GOODS
            self::SHIPPING_INDICATOR_TRAVEL_AND_EVENT_TICKETS
            self::SHIPPING_INDICATOR_OTHER
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['delivery_email'] = isset($data['delivery_email']) ? $data['delivery_email'] : null;
        $this->container['delivery_timeframe'] = isset($data['delivery_timeframe']) ? $data['delivery_timeframe'] : null;
        $this->container['gift_card_amount'] = isset($data['gift_card_amount']) ? $data['gift_card_amount'] : null;
        $this->container['gift_card_count'] = isset($data['gift_card_count']) ? $data['gift_card_count'] : null;
        $this->container['gift_card_currency'] = isset($data['gift_card_currency']) ? $data['gift_card_currency'] : null;
        $this->container['pre_order_date'] = isset($data['pre_order_date']) ? $data['pre_order_date'] : null;
        $this->container['pre_order_purchase_indicator'] = isset($data['pre_order_purchase_indicator']) ? $data['pre_order_purchase_indicator'] : null;
        $this->container['reorder_items_indicator'] = isset($data['reorder_items_indicator']) ? $data['reorder_items_indicator'] : null;
        $this->container['shipping_indicator'] = isset($data['shipping_indicator']) ? $data['shipping_indicator'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getDeliveryTimeframeAllowableValues();
        if (!is_null($this->container['delivery_timeframe']) && !in_array($this->container['delivery_timeframe'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'delivery_timeframe', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getPreOrderPurchaseIndicatorAllowableValues();
        if (!is_null($this->container['pre_order_purchase_indicator']) && !in_array($this->container['pre_order_purchase_indicator'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'pre_order_purchase_indicator', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getReorderItemsIndicatorAllowableValues();
        if (!is_null($this->container['reorder_items_indicator']) && !in_array($this->container['reorder_items_indicator'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'reorder_items_indicator', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getShippingIndicatorAllowableValues();
        if (!is_null($this->container['shipping_indicator']) && !in_array($this->container['shipping_indicator'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'shipping_indicator', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets delivery_email
     *
     * @return string
     */
    public function getDeliveryEmail()
    {
        return $this->container['delivery_email'];
    }

    /**
     * Sets delivery_email
     *
     * @param string $delivery_email For Electronic delivery, the email address to which the merchandise was delivered. Must be RFC5322 compliant.
     *
     * @return $this
     */
    public function setDeliveryEmail($delivery_email)
    {
        $this->container['delivery_email'] = $delivery_email;

        return $this;
    }

    /**
     * Gets delivery_timeframe
     *
     * @return string
     */
    public function getDeliveryTimeframe()
    {
        return $this->container['delivery_timeframe'];
    }

    /**
     * Sets delivery_timeframe
     *
     * @param string $delivery_timeframe Indicates the merchandise delivery timeframe: `electronic` - Electronic Delivery, `same_day_shipping` - Same day shipping, `overnight_shipping` - Overnight shipping, `two_day_or_more_shipping` - Two-day or more shipping
     *
     * @return $this
     */
    public function setDeliveryTimeframe($delivery_timeframe)
    {
        $allowedValues = $this->getDeliveryTimeframeAllowableValues();
        if (!is_null($delivery_timeframe) && !in_array($delivery_timeframe, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'delivery_timeframe', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['delivery_timeframe'] = $delivery_timeframe;

        return $this;
    }

    /**
     * Gets gift_card_amount
     *
     * @return int
     */
    public function getGiftCardAmount()
    {
        return $this->container['gift_card_amount'];
    }

    /**
     * Sets gift_card_amount
     *
     * @param int $gift_card_amount For prepaid or gift card purchase, the purchase amount total of prepaid or gift card(s) in major units (for example, USD 123.45 is 123).
     *
     * @return $this
     */
    public function setGiftCardAmount($gift_card_amount)
    {
        $this->container['gift_card_amount'] = $gift_card_amount;

        return $this;
    }

    /**
     * Gets gift_card_count
     *
     * @return int
     */
    public function getGiftCardCount()
    {
        return $this->container['gift_card_count'];
    }

    /**
     * Sets gift_card_count
     *
     * @param int $gift_card_count For prepaid or gift card purchase, total count of individual prepaid or gift cards/codes purchased.
     *
     * @return $this
     */
    public function setGiftCardCount($gift_card_count)
    {
        $this->container['gift_card_count'] = $gift_card_count;

        return $this;
    }

    /**
     * Gets gift_card_currency
     *
     * @return string
     */
    public function getGiftCardCurrency()
    {
        return $this->container['gift_card_currency'];
    }

    /**
     * Sets gift_card_currency
     *
     * @param string $gift_card_currency For prepaid or gift card purchase, currency code of the gift card in [ISO 4217](http://da.wikipedia.org/wiki/ISO_4217) three letter alpha code.
     *
     * @return $this
     */
    public function setGiftCardCurrency($gift_card_currency)
    {
        $this->container['gift_card_currency'] = $gift_card_currency;

        return $this;
    }

    /**
     * Gets pre_order_date
     *
     * @return string
     */
    public function getPreOrderDate()
    {
        return $this->container['pre_order_date'];
    }

    /**
     * Sets pre_order_date
     *
     * @param string $pre_order_date For a pre-ordered purchase, the expected local date that the merchandise will be available. Local date on the form `yyyy-MM-dd`
     *
     * @return $this
     */
    public function setPreOrderDate($pre_order_date)
    {
        $this->container['pre_order_date'] = $pre_order_date;

        return $this;
    }

    /**
     * Gets pre_order_purchase_indicator
     *
     * @return string
     */
    public function getPreOrderPurchaseIndicator()
    {
        return $this->container['pre_order_purchase_indicator'];
    }

    /**
     * Sets pre_order_purchase_indicator
     *
     * @param string $pre_order_purchase_indicator Indicates whether cardholder is placing an order for merchandise with a future availability or release date. Either: `merchandise_available` or `future_availability`
     *
     * @return $this
     */
    public function setPreOrderPurchaseIndicator($pre_order_purchase_indicator)
    {
        $allowedValues = $this->getPreOrderPurchaseIndicatorAllowableValues();
        if (!is_null($pre_order_purchase_indicator) && !in_array($pre_order_purchase_indicator, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'pre_order_purchase_indicator', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['pre_order_purchase_indicator'] = $pre_order_purchase_indicator;

        return $this;
    }

    /**
     * Gets reorder_items_indicator
     *
     * @return string
     */
    public function getReorderItemsIndicator()
    {
        return $this->container['reorder_items_indicator'];
    }

    /**
     * Sets reorder_items_indicator
     *
     * @param string $reorder_items_indicator Indicates whether the cardholder is reordering previously purchased merchandise. Either: `first_time_ordered` or `reordered`
     *
     * @return $this
     */
    public function setReorderItemsIndicator($reorder_items_indicator)
    {
        $allowedValues = $this->getReorderItemsIndicatorAllowableValues();
        if (!is_null($reorder_items_indicator) && !in_array($reorder_items_indicator, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'reorder_items_indicator', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['reorder_items_indicator'] = $reorder_items_indicator;

        return $this;
    }

    /**
     * Gets shipping_indicator
     *
     * @return string
     */
    public function getShippingIndicator()
    {
        return $this->container['shipping_indicator'];
    }

    /**
     * Sets shipping_indicator
     *
     * @param string $shipping_indicator Indicates shipping method chosen for the transaction. The Shipping Indicator code that most accurately describes the cardholder’s specific transaction must be used, not the general business. If one or more items are included in the sale, use the Shipping Indicator code for the physical goods, or if all digital goods, use the Shipping Indicator code that describes the most expensive item. Possible values: `billing_address` - Ship to cardholder’s billing address, `verified` - Ship to another verified address on file, `non_billing_address` - Ship to address that is different than the cardholder’s billing address, `ship_to_store` - Pick-up at local store (Store address shall be populated in shipping address fields), `digital_goods` - Digital goods (includes online services, electronic gift cards and redemption codes), `travel_and_event_tickets` - Travel and Event tickets, not shipped, `other` - Other (for example, Gaming, digital services not shipped, emedia subscriptions, etc.)
     *
     * @return $this
     */
    public function setShippingIndicator($shipping_indicator)
    {
        $allowedValues = $this->getShippingIndicatorAllowableValues();
        if (!is_null($shipping_indicator) && !in_array($shipping_indicator, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'shipping_indicator', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['shipping_indicator'] = $shipping_indicator;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
