<?php
/**
 * ChargeSource
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Reepay Checkout API
 *
 * Reepay Checkout REST API
 *
 * OpenAPI spec version: 1
 * Contact: open.source@driveoscar.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * ChargeSource Class Doc Comment
 *
 * @category Class
 * @description Object describing the source for the charge. E.g. credit card.
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ChargeSource implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ChargeSource';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'type' => 'string',
        'card' => 'string',
        'mps' => 'string',
        'iban' => 'string',
        'fingerprint' => 'string',
        'provider' => 'string',
        'frictionless' => 'bool',
        'vipps_recurring' => 'string',
        'sepa_mandate' => 'string',
        'offline_agreement_handle' => 'string',
        'auth_transaction' => 'string',
        'card_type' => 'string',
        'transaction_card_type' => 'string',
        'exp_date' => 'string',
        'masked_card' => 'string',
        'card_country' => 'string',
        'strong_authentication_status' => 'string',
        'three_d_secure_status' => 'string',
        'risk_rule' => 'string',
        'acquirer_code' => 'string',
        'acquirer_message' => 'string',
        'acquirer_reference' => 'string',
        'text_on_statement' => 'string',
        'surcharge_fee' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'type' => null,
        'card' => null,
        'mps' => null,
        'iban' => null,
        'fingerprint' => null,
        'provider' => null,
        'frictionless' => null,
        'vipps_recurring' => null,
        'sepa_mandate' => null,
        'offline_agreement_handle' => null,
        'auth_transaction' => null,
        'card_type' => null,
        'transaction_card_type' => null,
        'exp_date' => null,
        'masked_card' => null,
        'card_country' => null,
        'strong_authentication_status' => null,
        'three_d_secure_status' => null,
        'risk_rule' => null,
        'acquirer_code' => null,
        'acquirer_message' => null,
        'acquirer_reference' => null,
        'text_on_statement' => null,
        'surcharge_fee' => 'int32'
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'type' => 'type',
        'card' => 'card',
        'mps' => 'mps',
        'iban' => 'iban',
        'fingerprint' => 'fingerprint',
        'provider' => 'provider',
        'frictionless' => 'frictionless',
        'vipps_recurring' => 'vipps_recurring',
        'sepa_mandate' => 'sepa_mandate',
        'offline_agreement_handle' => 'offline_agreement_handle',
        'auth_transaction' => 'auth_transaction',
        'card_type' => 'card_type',
        'transaction_card_type' => 'transaction_card_type',
        'exp_date' => 'exp_date',
        'masked_card' => 'masked_card',
        'card_country' => 'card_country',
        'strong_authentication_status' => 'strong_authentication_status',
        'three_d_secure_status' => 'three_d_secure_status',
        'risk_rule' => 'risk_rule',
        'acquirer_code' => 'acquirer_code',
        'acquirer_message' => 'acquirer_message',
        'acquirer_reference' => 'acquirer_reference',
        'text_on_statement' => 'text_on_statement',
        'surcharge_fee' => 'surcharge_fee'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'type' => 'setType',
        'card' => 'setCard',
        'mps' => 'setMps',
        'iban' => 'setIban',
        'fingerprint' => 'setFingerprint',
        'provider' => 'setProvider',
        'frictionless' => 'setFrictionless',
        'vipps_recurring' => 'setVippsRecurring',
        'sepa_mandate' => 'setSepaMandate',
        'offline_agreement_handle' => 'setOfflineAgreementHandle',
        'auth_transaction' => 'setAuthTransaction',
        'card_type' => 'setCardType',
        'transaction_card_type' => 'setTransactionCardType',
        'exp_date' => 'setExpDate',
        'masked_card' => 'setMaskedCard',
        'card_country' => 'setCardCountry',
        'strong_authentication_status' => 'setStrongAuthenticationStatus',
        'three_d_secure_status' => 'setThreeDSecureStatus',
        'risk_rule' => 'setRiskRule',
        'acquirer_code' => 'setAcquirerCode',
        'acquirer_message' => 'setAcquirerMessage',
        'acquirer_reference' => 'setAcquirerReference',
        'text_on_statement' => 'setTextOnStatement',
        'surcharge_fee' => 'setSurchargeFee'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'type' => 'getType',
        'card' => 'getCard',
        'mps' => 'getMps',
        'iban' => 'getIban',
        'fingerprint' => 'getFingerprint',
        'provider' => 'getProvider',
        'frictionless' => 'getFrictionless',
        'vipps_recurring' => 'getVippsRecurring',
        'sepa_mandate' => 'getSepaMandate',
        'offline_agreement_handle' => 'getOfflineAgreementHandle',
        'auth_transaction' => 'getAuthTransaction',
        'card_type' => 'getCardType',
        'transaction_card_type' => 'getTransactionCardType',
        'exp_date' => 'getExpDate',
        'masked_card' => 'getMaskedCard',
        'card_country' => 'getCardCountry',
        'strong_authentication_status' => 'getStrongAuthenticationStatus',
        'three_d_secure_status' => 'getThreeDSecureStatus',
        'risk_rule' => 'getRiskRule',
        'acquirer_code' => 'getAcquirerCode',
        'acquirer_message' => 'getAcquirerMessage',
        'acquirer_reference' => 'getAcquirerReference',
        'text_on_statement' => 'getTextOnStatement',
        'surcharge_fee' => 'getSurchargeFee'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const TYPE_CARD_TOKEN = 'card_token';
    const TYPE_CARD = 'card';
    const TYPE_MPO = 'mpo';
    const TYPE_VIPPS = 'vipps';
    const TYPE_VIPPS_RECURRING = 'vipps_recurring';
    const TYPE_SWISH = 'swish';
    const TYPE_VIABILL = 'viabill';
    const TYPE_ANYDAY = 'anyday';
    const TYPE_MANUAL = 'manual';
    const TYPE_APPLEPAY = 'applepay';
    const TYPE_GOOGLEPAY = 'googlepay';
    const TYPE_PAYPAL = 'paypal';
    const TYPE_KLARNA_PAY_NOW = 'klarna_pay_now';
    const TYPE_KLARNA_PAY_LATER = 'klarna_pay_later';
    const TYPE_KLARNA_SLICE_IT = 'klarna_slice_it';
    const TYPE_KLARNA_DIRECT_BANK_TRANSFER = 'klarna_direct_bank_transfer';
    const TYPE_KLARNA_DIRECT_DEBIT = 'klarna_direct_debit';
    const TYPE_RESURS = 'resurs';
    const TYPE_IDEAL = 'ideal';
    const TYPE_P24 = 'p24';
    const TYPE_BLIK = 'blik';
    const TYPE_GIROPAY = 'giropay';
    const TYPE_SEPA = 'sepa';
    const TYPE_VERKKOPANKKI = 'verkkopankki';
    const TYPE_MOBILEPAY_SUBSCRIPTIONS = 'mobilepay_subscriptions';
    const TYPE_EMV_TOKEN = 'emv_token';
    const TYPE_BCMC = 'bcmc';
    const TYPE_PP_BLIK_OC = 'pp_blik_oc';
    const TYPE_TRUSTLY = 'trustly';
    const TYPE_EPS = 'eps';
    const TYPE_ESTONIA_BANKS = 'estonia_banks';
    const TYPE_LATVIA_BANKS = 'latvia_banks';
    const TYPE_LITHUANIA_BANKS = 'lithuania_banks';
    const TYPE_MB_WAY = 'mb_way';
    const TYPE_MULTIBANCO = 'multibanco';
    const TYPE_MYBANK = 'mybank';
    const TYPE_PAYCONIQ = 'payconiq';
    const TYPE_PAYSAFECARD = 'paysafecard';
    const TYPE_PAYSERA = 'paysera';
    const TYPE_POSTFINANCE = 'postfinance';
    const TYPE_SATISPAY = 'satispay';
    const TYPE_WECHATPAY = 'wechatpay';
    const TYPE_SANTANDER = 'santander';
    const TYPE_OFFLINE_CASH = 'offline_cash';
    const TYPE_OFFLINE_BANK_TRANSFER = 'offline_bank_transfer';
    const TYPE_OFFLINE_OTHER = 'offline_other';
    const PROVIDER_REEPAY = 'reepay';
    const PROVIDER_CLEARHAUS = 'clearhaus';
    const PROVIDER_NETS = 'nets';
    const PROVIDER_SWEDBANK = 'swedbank';
    const PROVIDER_HANDELSBANKEN = 'handelsbanken';
    const PROVIDER_ELAVON = 'elavon';
    const PROVIDER_BAMBORA = 'bambora';
    const PROVIDER_VALITOR = 'valitor';
    const PROVIDER_DIBS = 'dibs';
    const PROVIDER_STRIPE = 'stripe';
    const PROVIDER_EPAY = 'epay';
    const PROVIDER_TEST = 'test';
    const CARD_TYPE_UNKNOWN = 'unknown';
    const CARD_TYPE_VISA = 'visa';
    const CARD_TYPE_MC = 'mc';
    const CARD_TYPE_DANKORT = 'dankort';
    const CARD_TYPE_VISA_DK = 'visa_dk';
    const CARD_TYPE_FFK = 'ffk';
    const CARD_TYPE_VISA_ELEC = 'visa_elec';
    const CARD_TYPE_MAESTRO = 'maestro';
    const CARD_TYPE_LASER = 'laser';
    const CARD_TYPE_AMEX = 'amex';
    const CARD_TYPE_DINERS = 'diners';
    const CARD_TYPE_DISCOVER = 'discover';
    const CARD_TYPE_JCB = 'jcb';
    const TRANSACTION_CARD_TYPE_UNKNOWN = 'unknown';
    const TRANSACTION_CARD_TYPE_VISA = 'visa';
    const TRANSACTION_CARD_TYPE_MC = 'mc';
    const TRANSACTION_CARD_TYPE_DANKORT = 'dankort';
    const TRANSACTION_CARD_TYPE_VISA_DK = 'visa_dk';
    const TRANSACTION_CARD_TYPE_FFK = 'ffk';
    const TRANSACTION_CARD_TYPE_VISA_ELEC = 'visa_elec';
    const TRANSACTION_CARD_TYPE_MAESTRO = 'maestro';
    const TRANSACTION_CARD_TYPE_LASER = 'laser';
    const TRANSACTION_CARD_TYPE_AMEX = 'amex';
    const TRANSACTION_CARD_TYPE_DINERS = 'diners';
    const TRANSACTION_CARD_TYPE_DISCOVER = 'discover';
    const TRANSACTION_CARD_TYPE_JCB = 'jcb';
    const STRONG_AUTHENTICATION_STATUS_THREED_SECURE = 'threed_secure';
    const STRONG_AUTHENTICATION_STATUS_THREED_SECURE_NOT_ENROLLED = 'threed_secure_not_enrolled';
    const STRONG_AUTHENTICATION_STATUS_SECURED_BY_NETS = 'secured_by_nets';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_CARD_TOKEN,
            self::TYPE_CARD,
            self::TYPE_MPO,
            self::TYPE_VIPPS,
            self::TYPE_VIPPS_RECURRING,
            self::TYPE_SWISH,
            self::TYPE_VIABILL,
            self::TYPE_ANYDAY,
            self::TYPE_MANUAL,
            self::TYPE_APPLEPAY,
            self::TYPE_GOOGLEPAY,
            self::TYPE_PAYPAL,
            self::TYPE_KLARNA_PAY_NOW,
            self::TYPE_KLARNA_PAY_LATER,
            self::TYPE_KLARNA_SLICE_IT,
            self::TYPE_KLARNA_DIRECT_BANK_TRANSFER,
            self::TYPE_KLARNA_DIRECT_DEBIT,
            self::TYPE_RESURS,
            self::TYPE_IDEAL,
            self::TYPE_P24,
            self::TYPE_BLIK,
            self::TYPE_GIROPAY,
            self::TYPE_SEPA,
            self::TYPE_VERKKOPANKKI,
            self::TYPE_MOBILEPAY_SUBSCRIPTIONS,
            self::TYPE_EMV_TOKEN,
            self::TYPE_BCMC,
            self::TYPE_PP_BLIK_OC,
            self::TYPE_TRUSTLY,
            self::TYPE_EPS,
            self::TYPE_ESTONIA_BANKS,
            self::TYPE_LATVIA_BANKS,
            self::TYPE_LITHUANIA_BANKS,
            self::TYPE_MB_WAY,
            self::TYPE_MULTIBANCO,
            self::TYPE_MYBANK,
            self::TYPE_PAYCONIQ,
            self::TYPE_PAYSAFECARD,
            self::TYPE_PAYSERA,
            self::TYPE_POSTFINANCE,
            self::TYPE_SATISPAY,
            self::TYPE_WECHATPAY,
            self::TYPE_SANTANDER,
            self::TYPE_OFFLINE_CASH,
            self::TYPE_OFFLINE_BANK_TRANSFER,
            self::TYPE_OFFLINE_OTHER,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getProviderAllowableValues()
    {
        return [
            self::PROVIDER_REEPAY,
            self::PROVIDER_CLEARHAUS,
            self::PROVIDER_NETS,
            self::PROVIDER_SWEDBANK,
            self::PROVIDER_HANDELSBANKEN,
            self::PROVIDER_ELAVON,
            self::PROVIDER_BAMBORA,
            self::PROVIDER_VALITOR,
            self::PROVIDER_DIBS,
            self::PROVIDER_STRIPE,
            self::PROVIDER_EPAY,
            self::PROVIDER_TEST,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getCardTypeAllowableValues()
    {
        return [
            self::CARD_TYPE_UNKNOWN,
            self::CARD_TYPE_VISA,
            self::CARD_TYPE_MC,
            self::CARD_TYPE_DANKORT,
            self::CARD_TYPE_VISA_DK,
            self::CARD_TYPE_FFK,
            self::CARD_TYPE_VISA_ELEC,
            self::CARD_TYPE_MAESTRO,
            self::CARD_TYPE_LASER,
            self::CARD_TYPE_AMEX,
            self::CARD_TYPE_DINERS,
            self::CARD_TYPE_DISCOVER,
            self::CARD_TYPE_JCB,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTransactionCardTypeAllowableValues()
    {
        return [
            self::TRANSACTION_CARD_TYPE_UNKNOWN,
            self::TRANSACTION_CARD_TYPE_VISA,
            self::TRANSACTION_CARD_TYPE_MC,
            self::TRANSACTION_CARD_TYPE_DANKORT,
            self::TRANSACTION_CARD_TYPE_VISA_DK,
            self::TRANSACTION_CARD_TYPE_FFK,
            self::TRANSACTION_CARD_TYPE_VISA_ELEC,
            self::TRANSACTION_CARD_TYPE_MAESTRO,
            self::TRANSACTION_CARD_TYPE_LASER,
            self::TRANSACTION_CARD_TYPE_AMEX,
            self::TRANSACTION_CARD_TYPE_DINERS,
            self::TRANSACTION_CARD_TYPE_DISCOVER,
            self::TRANSACTION_CARD_TYPE_JCB,
        ];
    }
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStrongAuthenticationStatusAllowableValues()
    {
        return [
            self::STRONG_AUTHENTICATION_STATUS_THREED_SECURE,
            self::STRONG_AUTHENTICATION_STATUS_THREED_SECURE_NOT_ENROLLED,
            self::STRONG_AUTHENTICATION_STATUS_SECURED_BY_NETS,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['card'] = isset($data['card']) ? $data['card'] : null;
        $this->container['mps'] = isset($data['mps']) ? $data['mps'] : null;
        $this->container['iban'] = isset($data['iban']) ? $data['iban'] : null;
        $this->container['fingerprint'] = isset($data['fingerprint']) ? $data['fingerprint'] : null;
        $this->container['provider'] = isset($data['provider']) ? $data['provider'] : null;
        $this->container['frictionless'] = isset($data['frictionless']) ? $data['frictionless'] : null;
        $this->container['vipps_recurring'] = isset($data['vipps_recurring']) ? $data['vipps_recurring'] : null;
        $this->container['sepa_mandate'] = isset($data['sepa_mandate']) ? $data['sepa_mandate'] : null;
        $this->container['offline_agreement_handle'] = isset($data['offline_agreement_handle']) ? $data['offline_agreement_handle'] : null;
        $this->container['auth_transaction'] = isset($data['auth_transaction']) ? $data['auth_transaction'] : null;
        $this->container['card_type'] = isset($data['card_type']) ? $data['card_type'] : null;
        $this->container['transaction_card_type'] = isset($data['transaction_card_type']) ? $data['transaction_card_type'] : null;
        $this->container['exp_date'] = isset($data['exp_date']) ? $data['exp_date'] : null;
        $this->container['masked_card'] = isset($data['masked_card']) ? $data['masked_card'] : null;
        $this->container['card_country'] = isset($data['card_country']) ? $data['card_country'] : null;
        $this->container['strong_authentication_status'] = isset($data['strong_authentication_status']) ? $data['strong_authentication_status'] : null;
        $this->container['three_d_secure_status'] = isset($data['three_d_secure_status']) ? $data['three_d_secure_status'] : null;
        $this->container['risk_rule'] = isset($data['risk_rule']) ? $data['risk_rule'] : null;
        $this->container['acquirer_code'] = isset($data['acquirer_code']) ? $data['acquirer_code'] : null;
        $this->container['acquirer_message'] = isset($data['acquirer_message']) ? $data['acquirer_message'] : null;
        $this->container['acquirer_reference'] = isset($data['acquirer_reference']) ? $data['acquirer_reference'] : null;
        $this->container['text_on_statement'] = isset($data['text_on_statement']) ? $data['text_on_statement'] : null;
        $this->container['surcharge_fee'] = isset($data['surcharge_fee']) ? $data['surcharge_fee'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['type'] === null) {
            $invalidProperties[] = "'type' can't be null";
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($this->container['type']) && !in_array($this->container['type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getProviderAllowableValues();
        if (!is_null($this->container['provider']) && !in_array($this->container['provider'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'provider', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getCardTypeAllowableValues();
        if (!is_null($this->container['card_type']) && !in_array($this->container['card_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'card_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTransactionCardTypeAllowableValues();
        if (!is_null($this->container['transaction_card_type']) && !in_array($this->container['transaction_card_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'transaction_card_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStrongAuthenticationStatusAllowableValues();
        if (!is_null($this->container['strong_authentication_status']) && !in_array($this->container['strong_authentication_status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'strong_authentication_status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type Type of charge source: `card` - existing customer card, `card_token` - card token, `mpo` - MobilePay Online, `vipps`, `vipps_recurring`, `swish`, `viabill`, `anyday`, `manual`, `applepay`, `googlepay`, `paypal`, `klarna_pay_now`, `klarna_pay_later`, `klarna_slice_it`, `klarna_direct_bank_transfer`, `klarna_direct_debit`, `resurs`, `mobilepay_subscriptions`, `emv_token`, `bcmc`, `blik`, `pp_blik_oc`, `giropay`, `ideal`, `p24`, `sepa`, `trustly`, `eps`, `estonia_banks`, `latvia_banks`, `lithuania_banks`, `mb_way`, `multibanco`, `mybank`, `payconiq`, `paysafecard`, `paysera`, `postfinance`, `satispay`, `wechatpay`, `santander`,  or `verkkopankki`, `offline_cash`, `offline_bank_transfer`, `offline_other`
     *
     * @return $this
     */
    public function setType($type)
    {
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets card
     *
     * @return string
     */
    public function getCard()
    {
        return $this->container['card'];
    }

    /**
     * Sets card
     *
     * @param string $card Reference to customer card if source type `card`
     *
     * @return $this
     */
    public function setCard($card)
    {
        $this->container['card'] = $card;

        return $this;
    }

    /**
     * Gets mps
     *
     * @return string
     */
    public function getMps()
    {
        return $this->container['mps'];
    }

    /**
     * Sets mps
     *
     * @param string $mps Reference to MobilePay Subscriptions payment method if source type `mobilepay_subscriptions`
     *
     * @return $this
     */
    public function setMps($mps)
    {
        $this->container['mps'] = $mps;

        return $this;
    }

    /**
     * Gets iban
     *
     * @return string
     */
    public function getIban()
    {
        return $this->container['iban'];
    }

    /**
     * Sets iban
     *
     * @param string $iban IBAN number if source type `sepa`
     *
     * @return $this
     */
    public function setIban($iban)
    {
        $this->container['iban'] = $iban;

        return $this;
    }

    /**
     * Gets fingerprint
     *
     * @return string
     */
    public function getFingerprint()
    {
        return $this->container['fingerprint'];
    }

    /**
     * Sets fingerprint
     *
     * @param string $fingerprint Uniquely identifies this particular card number if credit card source
     *
     * @return $this
     */
    public function setFingerprint($fingerprint)
    {
        $this->container['fingerprint'] = $fingerprint;

        return $this;
    }

    /**
     * Gets provider
     *
     * @return string
     */
    public function getProvider()
    {
        return $this->container['provider'];
    }

    /**
     * Sets provider
     *
     * @param string $provider Card acquirer or card payment gateway used if card source: `reepay`, `clearhaus`, `nets`, `swedbank`, `handelsbanken`, `elavon`, `bambora`, `valitor`, `dibs`, `stripe`, `epay`, `test`
     *
     * @return $this
     */
    public function setProvider($provider)
    {
        $allowedValues = $this->getProviderAllowableValues();
        if (!is_null($provider) && !in_array($provider, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'provider', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['provider'] = $provider;

        return $this;
    }

    /**
     * Gets frictionless
     *
     * @return bool
     */
    public function getFrictionless()
    {
        return $this->container['frictionless'];
    }

    /**
     * Sets frictionless
     *
     * @param bool $frictionless If the card transaction was exempted from a 3DS challenge
     *
     * @return $this
     */
    public function setFrictionless($frictionless)
    {
        $this->container['frictionless'] = $frictionless;

        return $this;
    }

    /**
     * Gets vipps_recurring
     *
     * @return string
     */
    public function getVippsRecurring()
    {
        return $this->container['vipps_recurring'];
    }

    /**
     * Sets vipps_recurring
     *
     * @param string $vipps_recurring Reference to Vipps Recurring Subscriptions payment method if source type `vipps_recurring`
     *
     * @return $this
     */
    public function setVippsRecurring($vipps_recurring)
    {
        $this->container['vipps_recurring'] = $vipps_recurring;

        return $this;
    }

    /**
     * Gets sepa_mandate
     *
     * @return string
     */
    public function getSepaMandate()
    {
        return $this->container['sepa_mandate'];
    }

    /**
     * Sets sepa_mandate
     *
     * @param string $sepa_mandate Reference to SEPA Mandate payment method if source type `sepa`
     *
     * @return $this
     */
    public function setSepaMandate($sepa_mandate)
    {
        $this->container['sepa_mandate'] = $sepa_mandate;

        return $this;
    }

    /**
     * Gets offline_agreement_handle
     *
     * @return string
     */
    public function getOfflineAgreementHandle()
    {
        return $this->container['offline_agreement_handle'];
    }

    /**
     * Sets offline_agreement_handle
     *
     * @param string $offline_agreement_handle Agreement handle if source type `offline_cash`, `offline_bank_transfer`, `offline_other`
     *
     * @return $this
     */
    public function setOfflineAgreementHandle($offline_agreement_handle)
    {
        $this->container['offline_agreement_handle'] = $offline_agreement_handle;

        return $this;
    }

    /**
     * Gets auth_transaction
     *
     * @return string
     */
    public function getAuthTransaction()
    {
        return $this->container['auth_transaction'];
    }

    /**
     * Sets auth_transaction
     *
     * @param string $auth_transaction Reference to authorization transaction if charge is settled after authorization
     *
     * @return $this
     */
    public function setAuthTransaction($auth_transaction)
    {
        $this->container['auth_transaction'] = $auth_transaction;

        return $this;
    }

    /**
     * Gets card_type
     *
     * @return string
     */
    public function getCardType()
    {
        return $this->container['card_type'];
    }

    /**
     * Sets card_type
     *
     * @param string $card_type Card type if credit card source: `unknown`, `visa`, `mc`, `dankort`, `visa_dk`, `ffk`, `visa_elec`, `maestro`, `laser`, `amex`, `diners`, `discover` or `jcb`
     *
     * @return $this
     */
    public function setCardType($card_type)
    {
        $allowedValues = $this->getCardTypeAllowableValues();
        if (!is_null($card_type) && !in_array($card_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'card_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['card_type'] = $card_type;

        return $this;
    }

    /**
     * Gets transaction_card_type
     *
     * @return string
     */
    public function getTransactionCardType()
    {
        return $this->container['transaction_card_type'];
    }

    /**
     * Sets transaction_card_type
     *
     * @param string $transaction_card_type Transaction card type if credit card source. Will differ from `card_type` if co-branded card. Transaction card type is the card type used for the transaction. `unknown`, `visa`, `mc`, `dankort`, `visa_dk`, `ffk`, `visa_elec`, `maestro`, `laser`, `amex`, `diners`, `discover` or `jcb`
     *
     * @return $this
     */
    public function setTransactionCardType($transaction_card_type)
    {
        $allowedValues = $this->getTransactionCardTypeAllowableValues();
        if (!is_null($transaction_card_type) && !in_array($transaction_card_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'transaction_card_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['transaction_card_type'] = $transaction_card_type;

        return $this;
    }

    /**
     * Gets exp_date
     *
     * @return string
     */
    public function getExpDate()
    {
        return $this->container['exp_date'];
    }

    /**
     * Sets exp_date
     *
     * @param string $exp_date Card expire date on form MM-YY if credit card source
     *
     * @return $this
     */
    public function setExpDate($exp_date)
    {
        $this->container['exp_date'] = $exp_date;

        return $this;
    }

    /**
     * Gets masked_card
     *
     * @return string
     */
    public function getMaskedCard()
    {
        return $this->container['masked_card'];
    }

    /**
     * Sets masked_card
     *
     * @param string $masked_card Masked card number if credit card source
     *
     * @return $this
     */
    public function setMaskedCard($masked_card)
    {
        $this->container['masked_card'] = $masked_card;

        return $this;
    }

    /**
     * Gets card_country
     *
     * @return string
     */
    public function getCardCountry()
    {
        return $this->container['card_country'];
    }

    /**
     * Sets card_country
     *
     * @param string $card_country Card issuing country if credit card source, in [ISO 3166-1 alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     *
     * @return $this
     */
    public function setCardCountry($card_country)
    {
        $this->container['card_country'] = $card_country;

        return $this;
    }

    /**
     * Gets strong_authentication_status
     *
     * @return string
     */
    public function getStrongAuthenticationStatus()
    {
        return $this->container['strong_authentication_status'];
    }

    /**
     * Sets strong_authentication_status
     *
     * @param string $strong_authentication_status Status for strong customer authentication: `threed_secure` - 3D Secure authenticated, `threed_secure_not_enrolled` - 3D Secure authentication not performed as card not enrolled, `secured_by_nets` - Secure by Nets authenticated
     *
     * @return $this
     */
    public function setStrongAuthenticationStatus($strong_authentication_status)
    {
        $allowedValues = $this->getStrongAuthenticationStatusAllowableValues();
        if (!is_null($strong_authentication_status) && !in_array($strong_authentication_status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'strong_authentication_status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['strong_authentication_status'] = $strong_authentication_status;

        return $this;
    }

    /**
     * Gets three_d_secure_status
     *
     * @return string
     */
    public function getThreeDSecureStatus()
    {
        return $this->container['three_d_secure_status'];
    }

    /**
     * Sets three_d_secure_status
     *
     * @param string $three_d_secure_status If 3D Secure authenticated the 3D status will either be `Y` (fully authenticated) or `A` (attempted authenticated). An attempted authentication means that card issuer (e.g. bank) does not support 3D Secure so no full authentication has been performed. Attempted authentication normally means liability shift, but this can differ between acquirers.
     *
     * @return $this
     */
    public function setThreeDSecureStatus($three_d_secure_status)
    {
        $this->container['three_d_secure_status'] = $three_d_secure_status;

        return $this;
    }

    /**
     * Gets risk_rule
     *
     * @return string
     */
    public function getRiskRule()
    {
        return $this->container['risk_rule'];
    }

    /**
     * Sets risk_rule
     *
     * @param string $risk_rule If this parameter is set the charge has either been flagged or declined by a Reepay Risk Filter rule. For flag action rules the charge can be successful, but may require special attention. For block action rules the decline error will be `risk_filter_block`.
     *
     * @return $this
     */
    public function setRiskRule($risk_rule)
    {
        $this->container['risk_rule'] = $risk_rule;

        return $this;
    }

    /**
     * Gets acquirer_code
     *
     * @return string
     */
    public function getAcquirerCode()
    {
        return $this->container['acquirer_code'];
    }

    /**
     * Sets acquirer_code
     *
     * @param string $acquirer_code Card acquirer error code in case of card error
     *
     * @return $this
     */
    public function setAcquirerCode($acquirer_code)
    {
        $this->container['acquirer_code'] = $acquirer_code;

        return $this;
    }

    /**
     * Gets acquirer_message
     *
     * @return string
     */
    public function getAcquirerMessage()
    {
        return $this->container['acquirer_message'];
    }

    /**
     * Sets acquirer_message
     *
     * @param string $acquirer_message Acquirer message in case of error
     *
     * @return $this
     */
    public function setAcquirerMessage($acquirer_message)
    {
        $this->container['acquirer_message'] = $acquirer_message;

        return $this;
    }

    /**
     * Gets acquirer_reference
     *
     * @return string
     */
    public function getAcquirerReference()
    {
        return $this->container['acquirer_reference'];
    }

    /**
     * Sets acquirer_reference
     *
     * @param string $acquirer_reference Card acquirer reference to transaction in case of card source. E.g. Nets order id or Clearhaus reference.
     *
     * @return $this
     */
    public function setAcquirerReference($acquirer_reference)
    {
        $this->container['acquirer_reference'] = $acquirer_reference;

        return $this;
    }

    /**
     * Gets text_on_statement
     *
     * @return string
     */
    public function getTextOnStatement()
    {
        return $this->container['text_on_statement'];
    }

    /**
     * Sets text_on_statement
     *
     * @param string $text_on_statement Resulting text on bank statement if known
     *
     * @return $this
     */
    public function setTextOnStatement($text_on_statement)
    {
        $this->container['text_on_statement'] = $text_on_statement;

        return $this;
    }

    /**
     * Gets surcharge_fee
     *
     * @return int
     */
    public function getSurchargeFee()
    {
        return $this->container['surcharge_fee'];
    }

    /**
     * Sets surcharge_fee
     *
     * @param int $surcharge_fee Potential card surcharge fee added to amount if surcharging enabled
     *
     * @return $this
     */
    public function setSurchargeFee($surcharge_fee)
    {
        $this->container['surcharge_fee'] = $surcharge_fee;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
