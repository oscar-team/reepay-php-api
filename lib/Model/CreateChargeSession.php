<?php
/**
 * CreateChargeSession
 *
 * PHP version 5
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Reepay Checkout API
 *
 * Reepay Checkout REST API
 *
 * OpenAPI spec version: 1
 * Contact: open.source@driveoscar.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Reepay\Model;

use \ArrayAccess;
use \Reepay\ObjectSerializer;

/**
 * CreateChargeSession Class Doc Comment
 *
 * @category Class
 * @package  Reepay
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class CreateChargeSession implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'CreateChargeSession';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'configuration' => 'string',
        'locale' => 'string',
        'ttl' => 'string',
        'phone' => 'string',
        'invoice' => 'string',
        'settle' => 'bool',
        'order' => '\Reepay\Model\Order',
        'recurring' => 'bool',
        'accept_url' => 'string',
        'cancel_url' => 'string',
        'payment_methods' => 'string[]',
        'card_on_file' => 'string',
        'card_on_file_require_cvv' => 'bool',
        'card_on_file_require_exp_date' => 'bool',
        'button_text' => 'string',
        'recurring_average_amount' => 'int',
        'sca_data' => '\Reepay\Model\ScaData',
        'session_data' => '\Reepay\Model\SessionData',
        'payment_method_reference' => 'string',
        'account_funding' => 'bool',
        'account_funding_information' => '\Reepay\Model\AccountFundingInformation',
        'agreement_filter' => 'string[]',
        'offline_agreement_filter' => 'string[]',
        'allowed_ip' => 'string',
        'text_on_statement' => 'string',
        'acquirer_reference' => 'string',
        'recurring_optional' => 'bool',
        'recurring_optional_text' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'configuration' => null,
        'locale' => null,
        'ttl' => null,
        'phone' => null,
        'invoice' => null,
        'settle' => null,
        'order' => null,
        'recurring' => null,
        'accept_url' => null,
        'cancel_url' => null,
        'payment_methods' => null,
        'card_on_file' => null,
        'card_on_file_require_cvv' => null,
        'card_on_file_require_exp_date' => null,
        'button_text' => null,
        'recurring_average_amount' => 'int64',
        'sca_data' => null,
        'session_data' => null,
        'payment_method_reference' => null,
        'account_funding' => null,
        'account_funding_information' => null,
        'agreement_filter' => null,
        'offline_agreement_filter' => null,
        'allowed_ip' => null,
        'text_on_statement' => null,
        'acquirer_reference' => null,
        'recurring_optional' => null,
        'recurring_optional_text' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'configuration' => 'configuration',
        'locale' => 'locale',
        'ttl' => 'ttl',
        'phone' => 'phone',
        'invoice' => 'invoice',
        'settle' => 'settle',
        'order' => 'order',
        'recurring' => 'recurring',
        'accept_url' => 'accept_url',
        'cancel_url' => 'cancel_url',
        'payment_methods' => 'payment_methods',
        'card_on_file' => 'card_on_file',
        'card_on_file_require_cvv' => 'card_on_file_require_cvv',
        'card_on_file_require_exp_date' => 'card_on_file_require_exp_date',
        'button_text' => 'button_text',
        'recurring_average_amount' => 'recurring_average_amount',
        'sca_data' => 'sca_data',
        'session_data' => 'session_data',
        'payment_method_reference' => 'payment_method_reference',
        'account_funding' => 'account_funding',
        'account_funding_information' => 'account_funding_information',
        'agreement_filter' => 'agreement_filter',
        'offline_agreement_filter' => 'offline_agreement_filter',
        'allowed_ip' => 'allowed_ip',
        'text_on_statement' => 'text_on_statement',
        'acquirer_reference' => 'acquirer_reference',
        'recurring_optional' => 'recurring_optional',
        'recurring_optional_text' => 'recurring_optional_text'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'configuration' => 'setConfiguration',
        'locale' => 'setLocale',
        'ttl' => 'setTtl',
        'phone' => 'setPhone',
        'invoice' => 'setInvoice',
        'settle' => 'setSettle',
        'order' => 'setOrder',
        'recurring' => 'setRecurring',
        'accept_url' => 'setAcceptUrl',
        'cancel_url' => 'setCancelUrl',
        'payment_methods' => 'setPaymentMethods',
        'card_on_file' => 'setCardOnFile',
        'card_on_file_require_cvv' => 'setCardOnFileRequireCvv',
        'card_on_file_require_exp_date' => 'setCardOnFileRequireExpDate',
        'button_text' => 'setButtonText',
        'recurring_average_amount' => 'setRecurringAverageAmount',
        'sca_data' => 'setScaData',
        'session_data' => 'setSessionData',
        'payment_method_reference' => 'setPaymentMethodReference',
        'account_funding' => 'setAccountFunding',
        'account_funding_information' => 'setAccountFundingInformation',
        'agreement_filter' => 'setAgreementFilter',
        'offline_agreement_filter' => 'setOfflineAgreementFilter',
        'allowed_ip' => 'setAllowedIp',
        'text_on_statement' => 'setTextOnStatement',
        'acquirer_reference' => 'setAcquirerReference',
        'recurring_optional' => 'setRecurringOptional',
        'recurring_optional_text' => 'setRecurringOptionalText'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'configuration' => 'getConfiguration',
        'locale' => 'getLocale',
        'ttl' => 'getTtl',
        'phone' => 'getPhone',
        'invoice' => 'getInvoice',
        'settle' => 'getSettle',
        'order' => 'getOrder',
        'recurring' => 'getRecurring',
        'accept_url' => 'getAcceptUrl',
        'cancel_url' => 'getCancelUrl',
        'payment_methods' => 'getPaymentMethods',
        'card_on_file' => 'getCardOnFile',
        'card_on_file_require_cvv' => 'getCardOnFileRequireCvv',
        'card_on_file_require_exp_date' => 'getCardOnFileRequireExpDate',
        'button_text' => 'getButtonText',
        'recurring_average_amount' => 'getRecurringAverageAmount',
        'sca_data' => 'getScaData',
        'session_data' => 'getSessionData',
        'payment_method_reference' => 'getPaymentMethodReference',
        'account_funding' => 'getAccountFunding',
        'account_funding_information' => 'getAccountFundingInformation',
        'agreement_filter' => 'getAgreementFilter',
        'offline_agreement_filter' => 'getOfflineAgreementFilter',
        'allowed_ip' => 'getAllowedIp',
        'text_on_statement' => 'getTextOnStatement',
        'acquirer_reference' => 'getAcquirerReference',
        'recurring_optional' => 'getRecurringOptional',
        'recurring_optional_text' => 'getRecurringOptionalText'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }



    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['configuration'] = isset($data['configuration']) ? $data['configuration'] : null;
        $this->container['locale'] = isset($data['locale']) ? $data['locale'] : null;
        $this->container['ttl'] = isset($data['ttl']) ? $data['ttl'] : null;
        $this->container['phone'] = isset($data['phone']) ? $data['phone'] : null;
        $this->container['invoice'] = isset($data['invoice']) ? $data['invoice'] : null;
        $this->container['settle'] = isset($data['settle']) ? $data['settle'] : null;
        $this->container['order'] = isset($data['order']) ? $data['order'] : null;
        $this->container['recurring'] = isset($data['recurring']) ? $data['recurring'] : null;
        $this->container['accept_url'] = isset($data['accept_url']) ? $data['accept_url'] : null;
        $this->container['cancel_url'] = isset($data['cancel_url']) ? $data['cancel_url'] : null;
        $this->container['payment_methods'] = isset($data['payment_methods']) ? $data['payment_methods'] : null;
        $this->container['card_on_file'] = isset($data['card_on_file']) ? $data['card_on_file'] : null;
        $this->container['card_on_file_require_cvv'] = isset($data['card_on_file_require_cvv']) ? $data['card_on_file_require_cvv'] : null;
        $this->container['card_on_file_require_exp_date'] = isset($data['card_on_file_require_exp_date']) ? $data['card_on_file_require_exp_date'] : null;
        $this->container['button_text'] = isset($data['button_text']) ? $data['button_text'] : null;
        $this->container['recurring_average_amount'] = isset($data['recurring_average_amount']) ? $data['recurring_average_amount'] : null;
        $this->container['sca_data'] = isset($data['sca_data']) ? $data['sca_data'] : null;
        $this->container['session_data'] = isset($data['session_data']) ? $data['session_data'] : null;
        $this->container['payment_method_reference'] = isset($data['payment_method_reference']) ? $data['payment_method_reference'] : null;
        $this->container['account_funding'] = isset($data['account_funding']) ? $data['account_funding'] : null;
        $this->container['account_funding_information'] = isset($data['account_funding_information']) ? $data['account_funding_information'] : null;
        $this->container['agreement_filter'] = isset($data['agreement_filter']) ? $data['agreement_filter'] : null;
        $this->container['offline_agreement_filter'] = isset($data['offline_agreement_filter']) ? $data['offline_agreement_filter'] : null;
        $this->container['allowed_ip'] = isset($data['allowed_ip']) ? $data['allowed_ip'] : null;
        $this->container['text_on_statement'] = isset($data['text_on_statement']) ? $data['text_on_statement'] : null;
        $this->container['acquirer_reference'] = isset($data['acquirer_reference']) ? $data['acquirer_reference'] : null;
        $this->container['recurring_optional'] = isset($data['recurring_optional']) ? $data['recurring_optional'] : null;
        $this->container['recurring_optional_text'] = isset($data['recurring_optional_text']) ? $data['recurring_optional_text'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets configuration
     *
     * @return string
     */
    public function getConfiguration()
    {
        return $this->container['configuration'];
    }

    /**
     * Sets configuration
     *
     * @param string $configuration Optional handle for a checkout configuration defined in the admin app to be used for this session
     *
     * @return $this
     */
    public function setConfiguration($configuration)
    {
        $this->container['configuration'] = $configuration;

        return $this;
    }

    /**
     * Gets locale
     *
     * @return string
     */
    public function getLocale()
    {
        return $this->container['locale'];
    }

    /**
     * Sets locale
     *
     * @param string $locale Optional locale for session. E.g. `en_GB`, `da_DK`, `es_ES`. Defaults to configuration locale or account locale.
     *
     * @return $this
     */
    public function setLocale($locale)
    {
        $this->container['locale'] = $locale;

        return $this;
    }

    /**
     * Gets ttl
     *
     * @return string
     */
    public function getTtl()
    {
        return $this->container['ttl'];
    }

    /**
     * Sets ttl
     *
     * @param string $ttl Optional time-to-live duration. The session will expire after the duration from creation, meaning that payment attempts cannot be initiated after this duration. Notice though, that payments initiated within the time-to-live duration might finish after the TTL E.g. MobilePay Online flows. The duration must be given in the following notation: `PTxS` - x seconds, `PTxM` - x minutes, `PTxH` - x hours or `PxD` - x days. E.g. PT3H (three hours). The default time-to-live is three months.
     *
     * @return $this
     */
    public function setTtl($ttl)
    {
        $this->container['ttl'] = $ttl;

        return $this;
    }

    /**
     * Gets phone
     *
     * @return string
     */
    public function getPhone()
    {
        return $this->container['phone'];
    }

    /**
     * Sets phone
     *
     * @param string $phone Phone number to use for payment methods able to use a prefilled phone number. E.g. MobilePay, Vipps and Swish. If no explicit phone number is defined, the phone number for the customer entity will be used.
     *
     * @return $this
     */
    public function setPhone($phone)
    {
        $this->container['phone'] = $phone;

        return $this;
    }

    /**
     * Gets invoice
     *
     * @return string
     */
    public function getInvoice()
    {
        return $this->container['invoice'];
    }

    /**
     * Sets invoice
     *
     * @param string $invoice Handle for existing invoice to charge. Either this argument must be provided or `order`.
     *
     * @return $this
     */
    public function setInvoice($invoice)
    {
        $this->container['invoice'] = $invoice;

        return $this;
    }

    /**
     * Gets settle
     *
     * @return bool
     */
    public function getSettle()
    {
        return $this->container['settle'];
    }

    /**
     * Sets settle
     *
     * @param bool $settle Whether or not to immediately settle (capture). Default is false. If not settled immediately an authorization will be performed which can be settled later. Normally this have to be done within 7 days. Note that not all payment methods support immediate settle.
     *
     * @return $this
     */
    public function setSettle($settle)
    {
        $this->container['settle'] = $settle;

        return $this;
    }

    /**
     * Gets order
     *
     * @return \Reepay\Model\Order
     */
    public function getOrder()
    {
        return $this->container['order'];
    }

    /**
     * Sets order
     *
     * @param \Reepay\Model\Order $order order
     *
     * @return $this
     */
    public function setOrder($order)
    {
        $this->container['order'] = $order;

        return $this;
    }

    /**
     * Gets recurring
     *
     * @return bool
     */
    public function getRecurring()
    {
        return $this->container['recurring'];
    }

    /**
     * Sets recurring
     *
     * @param bool $recurring If set a recurring payment method is stored for the customer and a reference returned. This parameter if set to true will limit payment methods to those that are reusable. Cannot be used in conjunction with `recurring_optional`.
     *
     * @return $this
     */
    public function setRecurring($recurring)
    {
        $this->container['recurring'] = $recurring;

        return $this;
    }

    /**
     * Gets accept_url
     *
     * @return string
     */
    public function getAcceptUrl()
    {
        return $this->container['accept_url'];
    }

    /**
     * Sets accept_url
     *
     * @param string $accept_url If checkout is opened in separate window the customer will be directed to this page after success
     *
     * @return $this
     */
    public function setAcceptUrl($accept_url)
    {
        $this->container['accept_url'] = $accept_url;

        return $this;
    }

    /**
     * Gets cancel_url
     *
     * @return string
     */
    public function getCancelUrl()
    {
        return $this->container['cancel_url'];
    }

    /**
     * Sets cancel_url
     *
     * @param string $cancel_url If checkout is opened in separate window the customer will be directed to this page if the customer cancels
     *
     * @return $this
     */
    public function setCancelUrl($cancel_url)
    {
        $this->container['cancel_url'] = $cancel_url;

        return $this;
    }

    /**
     * Gets payment_methods
     *
     * @return string[]
     */
    public function getPaymentMethods()
    {
        return $this->container['payment_methods'];
    }

    /**
     * Sets payment_methods
     *
     * @param string[] $payment_methods Optional list of payment methods to use for the checkout session. Format: `<payment_methods> = list of <payment_method>` `<payment_method>  = [sca-|nosca-]<payment_name>` `<payment_name>    = The id of payment method, e.g. dankort` See https://docs.reepay.com/reference/checkout-payment-methods for full documentation
     *
     * @return $this
     */
    public function setPaymentMethods($payment_methods)
    {
        $this->container['payment_methods'] = $payment_methods;

        return $this;
    }

    /**
     * Gets card_on_file
     *
     * @return string
     */
    public function getCardOnFile()
    {
        return $this->container['card_on_file'];
    }

    /**
     * Sets card_on_file
     *
     * @param string $card_on_file Reference to existing card payment method (`ca_xxx`) to use instead of having cardholder enter card data. CVV may still be required from cardholder.
     *
     * @return $this
     */
    public function setCardOnFile($card_on_file)
    {
        $this->container['card_on_file'] = $card_on_file;

        return $this;
    }

    /**
     * Gets card_on_file_require_cvv
     *
     * @return bool
     */
    public function getCardOnFileRequireCvv()
    {
        return $this->container['card_on_file_require_cvv'];
    }

    /**
     * Sets card_on_file_require_cvv
     *
     * @param bool $card_on_file_require_cvv Require cvv from cardholder for card-on-file
     *
     * @return $this
     */
    public function setCardOnFileRequireCvv($card_on_file_require_cvv)
    {
        $this->container['card_on_file_require_cvv'] = $card_on_file_require_cvv;

        return $this;
    }

    /**
     * Gets card_on_file_require_exp_date
     *
     * @return bool
     */
    public function getCardOnFileRequireExpDate()
    {
        return $this->container['card_on_file_require_exp_date'];
    }

    /**
     * Sets card_on_file_require_exp_date
     *
     * @param bool $card_on_file_require_exp_date Require expiration date for card-on-file
     *
     * @return $this
     */
    public function setCardOnFileRequireExpDate($card_on_file_require_exp_date)
    {
        $this->container['card_on_file_require_exp_date'] = $card_on_file_require_exp_date;

        return $this;
    }

    /**
     * Gets button_text
     *
     * @return string
     */
    public function getButtonText()
    {
        return $this->container['button_text'];
    }

    /**
     * Sets button_text
     *
     * @param string $button_text Optional alternative button text. Maximum length 32 characters.
     *
     * @return $this
     */
    public function setButtonText($button_text)
    {
        $this->container['button_text'] = $button_text;

        return $this;
    }

    /**
     * Gets recurring_average_amount
     *
     * @return int
     */
    public function getRecurringAverageAmount()
    {
        return $this->container['recurring_average_amount'];
    }

    /**
     * Sets recurring_average_amount
     *
     * @param int $recurring_average_amount For cost based acquirer agreement selection this argument can be used to define the amount used in calculating the least expensive agreement for future recurring payments. Can only be used for sessions saving a payment method for later use. Must be given in minor unit for currency.
     *
     * @return $this
     */
    public function setRecurringAverageAmount($recurring_average_amount)
    {
        $this->container['recurring_average_amount'] = $recurring_average_amount;

        return $this;
    }

    /**
     * Gets sca_data
     *
     * @return \Reepay\Model\ScaData
     */
    public function getScaData()
    {
        return $this->container['sca_data'];
    }

    /**
     * Sets sca_data
     *
     * @param \Reepay\Model\ScaData $sca_data sca_data
     *
     * @return $this
     */
    public function setScaData($sca_data)
    {
        $this->container['sca_data'] = $sca_data;

        return $this;
    }

    /**
     * Gets session_data
     *
     * @return \Reepay\Model\SessionData
     */
    public function getSessionData()
    {
        return $this->container['session_data'];
    }

    /**
     * Sets session_data
     *
     * @param \Reepay\Model\SessionData $session_data session_data
     *
     * @return $this
     */
    public function setSessionData($session_data)
    {
        $this->container['session_data'] = $session_data;

        return $this;
    }

    /**
     * Gets payment_method_reference
     *
     * @return string
     */
    public function getPaymentMethodReference()
    {
        return $this->container['payment_method_reference'];
    }

    /**
     * Sets payment_method_reference
     *
     * @param string $payment_method_reference Optional reference given to the created payment method in case a recurring payment method is created by the session. Session id will be used by default if not defined. Max length 64 with allowable characters [a-zA-Z0-9_.-@].
     *
     * @return $this
     */
    public function setPaymentMethodReference($payment_method_reference)
    {
        $this->container['payment_method_reference'] = $payment_method_reference;

        return $this;
    }

    /**
     * Gets account_funding
     *
     * @return bool
     */
    public function getAccountFunding()
    {
        return $this->container['account_funding'];
    }

    /**
     * Sets account_funding
     *
     * @param bool $account_funding Indicates that Account Funding Transaction (AFT) is requested. It only can be used for instant settle (i.e. 'settle' = true)
     *
     * @return $this
     */
    public function setAccountFunding($account_funding)
    {
        $this->container['account_funding'] = $account_funding;

        return $this;
    }

    /**
     * Gets account_funding_information
     *
     * @return \Reepay\Model\AccountFundingInformation
     */
    public function getAccountFundingInformation()
    {
        return $this->container['account_funding_information'];
    }

    /**
     * Sets account_funding_information
     *
     * @param \Reepay\Model\AccountFundingInformation $account_funding_information account_funding_information
     *
     * @return $this
     */
    public function setAccountFundingInformation($account_funding_information)
    {
        $this->container['account_funding_information'] = $account_funding_information;

        return $this;
    }

    /**
     * Gets agreement_filter
     *
     * @return string[]
     */
    public function getAgreementFilter()
    {
        return $this->container['agreement_filter'];
    }

    /**
     * Sets agreement_filter
     *
     * @param string[] $agreement_filter Optional list of agreement ids to filter which agreements will be used for card payments.
     *
     * @return $this
     */
    public function setAgreementFilter($agreement_filter)
    {
        $this->container['agreement_filter'] = $agreement_filter;

        return $this;
    }

    /**
     * Gets offline_agreement_filter
     *
     * @return string[]
     */
    public function getOfflineAgreementFilter()
    {
        return $this->container['offline_agreement_filter'];
    }

    /**
     * Sets offline_agreement_filter
     *
     * @param string[] $offline_agreement_filter Optional list of offline agreement handles to filter which options are shown to the consumer.
     *
     * @return $this
     */
    public function setOfflineAgreementFilter($offline_agreement_filter)
    {
        $this->container['offline_agreement_filter'] = $offline_agreement_filter;

        return $this;
    }

    /**
     * Gets allowed_ip
     *
     * @return string
     */
    public function getAllowedIp()
    {
        return $this->container['allowed_ip'];
    }

    /**
     * Sets allowed_ip
     *
     * @param string $allowed_ip Optional IP address to restrict the use of the session to
     *
     * @return $this
     */
    public function setAllowedIp($allowed_ip)
    {
        $this->container['allowed_ip'] = $allowed_ip;

        return $this;
    }

    /**
     * Gets text_on_statement
     *
     * @return string
     */
    public function getTextOnStatement()
    {
        return $this->container['text_on_statement'];
    }

    /**
     * Sets text_on_statement
     *
     * @param string $text_on_statement Optional argument to define the text on bank statement. Notice the following about this argument: 1. It only works for some acquirers. 2. Acquirers may have rigid rules on the content of the text on statement. Not complying to these rules will result in declined payments. 3) It is already possible to define custom text on statement using templating in the Reepay Administration. Contact support for help. We highly recommend to only supply this argument if absolutely necessary, and the templated default text on statement is not sufficient. Maximum length is 128, but most acquirers require a maximum length of 22 characters. Truncating will be applied if too long for specific acquirer. Characters must match regex `[\\x20-\\x7F]`
     *
     * @return $this
     */
    public function setTextOnStatement($text_on_statement)
    {
        $this->container['text_on_statement'] = $text_on_statement;

        return $this;
    }

    /**
     * Gets acquirer_reference
     *
     * @return string
     */
    public function getAcquirerReference()
    {
        return $this->container['acquirer_reference'];
    }

    /**
     * Sets acquirer_reference
     *
     * @param string $acquirer_reference Optional reference for the transaction at the acquirer. Notice the following about this argument: 1. It only works for some acquirers. 2. Acquirers may have rigid rules on the content of the acquirer reference.  Not complying to these rules can result in declined payments. 3. It is already possible to define custom acquirer reference using templating in the Reepay Administration.  Contact support for help. We highly recommend to only supply this argument if absolutely necessary,  and the templated default acquirer reference is not sufficient. Maximum length is 128,  but most acquirers require a maximum length of 22 characters.  Truncating will be applied if too long for specific acquirer.  Characters must match regex `[\\x20-\\x7F]`
     *
     * @return $this
     */
    public function setAcquirerReference($acquirer_reference)
    {
        $this->container['acquirer_reference'] = $acquirer_reference;

        return $this;
    }

    /**
     * Gets recurring_optional
     *
     * @return bool
     */
    public function getRecurringOptional()
    {
        return $this->container['recurring_optional'];
    }

    /**
     * Sets recurring_optional
     *
     * @param bool $recurring_optional Option to show a checkbox for reusable payment methods to allow the customer to select to save the payment method or not. If set to true the checkbox will be checked by default and vice versa. If the customer chooses to save the payment method, the `payment_method` parameter will be returned. Cannot be used in conjunction with `recurring`.
     *
     * @return $this
     */
    public function setRecurringOptional($recurring_optional)
    {
        $this->container['recurring_optional'] = $recurring_optional;

        return $this;
    }

    /**
     * Gets recurring_optional_text
     *
     * @return string
     */
    public function getRecurringOptionalText()
    {
        return $this->container['recurring_optional_text'];
    }

    /**
     * Sets recurring_optional_text
     *
     * @param string $recurring_optional_text Optional alternative text to show if the `recurring_optional` option is used
     *
     * @return $this
     */
    public function setRecurringOptionalText($recurring_optional_text)
    {
        $this->container['recurring_optional_text'] = $recurring_optional_text;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
